<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Vulkan.Extensions.VK_NV_geometry_shader_passthrough</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">vulkan-3.8.1: Bindings to the Vulkan graphics API.</span><ul class="links" id="page-menu"><li><a href="src/Vulkan.Extensions.VK_NV_geometry_shader_passthrough.html">Source</a></li><li><a href="https://hackage.haskell.org/package/vulkan-3.8.1">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Vulkan.Extensions.VK_NV_geometry_shader_passthrough</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Name</h1><p>VK_NV_geometry_shader_passthrough - device extension</p><h2>VK_NV_geometry_shader_passthrough</h2><dl><dt><strong>Name String</strong></dt><dd><code>VK_NV_geometry_shader_passthrough</code></dd></dl><dl><dt><strong>Extension Type</strong></dt><dd>Device extension</dd><dt><strong>Registered Extension Number</strong></dt><dd>96</dd><dt><strong>Revision</strong></dt><dd>1</dd><dt><strong>Extension and Version Dependencies</strong></dt><dd><ul><li>Requires Vulkan 1.0</li></ul></dd><dt><strong>Contact</strong></dt><dd><ul><li>Daniel Koch
    <a href="https://github.com/KhronosGroup/Vulkan-Docs/issues/new?title=VK_NV_geometry_shader_passthrough:%20&amp;body=@dgkoch%20">https://github.com/KhronosGroup/Vulkan-Docs/issues/new?title=VK_NV_geometry_shader_passthrough:%20&amp;body=@dgkoch%20</a></li></ul></dd></dl><h2>Other Extension Metadata</h2><dl><dt><strong>Last Modified Date</strong></dt><dd>2017-02-15</dd></dl><dl><dt><strong>Interactions and External Dependencies</strong></dt><dd><ul><li>This extension requires
    <a href="https://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NV_geometry_shader_passthrough.html">SPV_NV_geometry_shader_passthrough</a></li><li>This extension provides API support for
    <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_geometry_shader_passthrough.txt">GL_NV_geometry_shader_passthrough</a></li><li>This extension requires the <code>geometryShader</code> feature.</li></ul></dd><dt><strong>Contributors</strong></dt><dd><ul><li>Piers Daniell, NVIDIA</li><li>Jeff Bolz, NVIDIA</li></ul></dd></dl><h2>Description</h2><p>This extension adds support for the following SPIR-V extension in
 Vulkan:</p><ul><li><pre>SPV_NV_geometry_shader_passthrough</pre></li></ul><p>Geometry shaders provide the ability for applications to process each
 primitive sent through the graphics pipeline using a programmable
 shader. However, one common use case treats them largely as a
 &#8220;passthrough&#8221;. In this use case, the bulk of the geometry shader code
 simply copies inputs from each vertex of the input primitive to
 corresponding outputs in the vertices of the output primitive. Such
 shaders might also compute values for additional built-in or
 user-defined per-primitive attributes (e.g., <code>Layer</code>) to be assigned to
 all the vertices of the output primitive.</p><p>This extension provides access to the <code>PassthroughNV</code> decoration under
 the <code>GeometryShaderPassthroughNV</code> capability. Adding this to a geometry
 shader input variable specifies that the values of this input are copied
 to the corresponding vertex of the output primitive.</p><p>When using GLSL source-based shading languages, the <code>passthrough</code> layout
 qualifier from <code>GL_NV_geometry_shader_passthrough</code> maps to the
 <code>PassthroughNV</code> decoration. To use the <code>passthrough</code> layout, in GLSL the
 <code>GL_NV_geometry_shader_passthrough</code> extension must be enabled. Behaviour
 is described in the <code>GL_NV_geometry_shader_passthrough</code> extension
 specification.</p><h2>New Enum Constants</h2><ul><li><code><a href="Vulkan-Extensions-VK_NV_geometry_shader_passthrough.html#t:NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME" title="Vulkan.Extensions.VK_NV_geometry_shader_passthrough">NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME</a></code></li></ul><ul><li><code><a href="Vulkan-Extensions-VK_NV_geometry_shader_passthrough.html#t:NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION" title="Vulkan.Extensions.VK_NV_geometry_shader_passthrough">NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION</a></code></li></ul><h2>New Variable Decoration</h2><ul><li><a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#geometry-passthrough-passthrough">PassthroughNV</a>
     in
     <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#geometry-passthrough">Geometry Shader Passthrough</a></li></ul><h2>New SPIR-V Capabilities</h2><ul><li><a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#spirvenv-capabilities-table-geometryshaderpassthrough">GeometryShaderPassthroughNV</a></li></ul><h2>Issues</h2><p>1) Should we require or allow a passthrough geometry shader to specify
 the output layout qualifiers for the output primitive type and maximum
 vertex count in the SPIR-V?</p><p><strong>RESOLVED</strong>: Yes they should be required in the SPIR-V. Per
 GL_NV_geometry_shader_passthrough they are not permitted in the GLSL
 source shader, but SPIR-V is lower-level. It is straightforward for the
 GLSL compiler to infer them from the input primitive type and to
 explicitly emit them in the SPIR-V according to the following table.</p><table><thead><tr><th> Input Layout                      </th><th> Implied Output Layout                    </th></tr></thead><tbody><tr><td> points                            </td><td> <code>layout(points, max_vertices=1)</code>         </td></tr><tr><td> lines                             </td><td> <code>layout(line_strip, max_vertices=2)</code>     </td></tr><tr><td> triangles                         </td><td> <code>layout(triangle_strip, max_vertices=3)</code> </td></tr></tbody></table><p>2) How does interface matching work with passthrough geometry shaders?</p><p><strong>RESOLVED</strong>: This is described in
 <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#geometry-passthrough-interface">Passthrough Interface Matching</a>.
 In GL when using passthough geometry shaders in separable mode, all
 inputs must also be explicitly assigned location layout qualifiers. In
 Vulkan all SPIR-V shader inputs (except built-ins) must also have
 location decorations specified. Redeclarations of built-in varables that
 add the passthrough layout qualifier are exempted from the rule
 requiring location assignment because built-in variables do not have
 locations and are matched by <code>BuiltIn</code> decoration.</p><h2>Sample Code</h2><p>Consider the following simple geometry shader in unextended GLSL:</p><pre>layout(triangles) in;
layout(triangle_strip) out;
layout(max_vertices=3) out;

in Inputs {
    vec2 texcoord;
    vec4 baseColor;
} v_in[];
out Outputs {
    vec2 texcoord;
    vec4 baseColor;
};

void main()
{
    int layer = compute_layer();
    for (int i = 0; i &lt; 3; i++) {
        gl_Position = gl_in[i].gl_Position;
        texcoord = v_in[i].texcoord;
        baseColor = v_in[i].baseColor;
        gl_Layer = layer;
        EmitVertex();
    }
}</pre><p>In this shader, the inputs <code>gl_Position</code>, <code>Inputs.texcoord</code>, and
 <code>Inputs.baseColor</code> are simply copied from the input vertex to the
 corresponding output vertex. The only &#8220;interesting&#8221; work done by the
 geometry shader is computing and emitting a <code>gl_Layer</code> value for the
 primitive.</p><p>The following geometry shader, using this extension, is equivalent:</p><pre>#extension GL_NV_geometry_shader_passthrough : require

layout(triangles) in;
// No output primitive layout qualifiers required.

// Redeclare gl_PerVertex to pass through &quot;gl_Position&quot;.
layout(passthrough) in gl_PerVertex {
    vec4 gl_Position;
} gl_in[];

// Declare &quot;Inputs&quot; with &quot;passthrough&quot; to automatically copy members.
layout(passthrough) in Inputs {
    vec2 texcoord;
    vec4 baseColor;
} v_in[];

// No output block declaration required.

void main()
{
    // The shader simply computes and writes gl_Layer.  We don't
    // loop over three vertices or call EmitVertex().
    gl_Layer = compute_layer();
}</pre><h2>Version History</h2><ul><li><p>Revision 1, 2017-02-15 (Daniel Koch)</p><ul><li>Internal revisions</li></ul></li></ul><h1>See Also</h1><p>No cross-references are available</p><h1>Document Notes</h1><p>For more information, see the
 <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_NV_geometry_shader_passthrough">Vulkan Specification</a></p><p>This page is a generated document. Fixes and changes should be made to
 the generator scripts, not directly.</p></div></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION" class="def">NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION</a> = 1 <a href="src/Vulkan.Extensions.VK_NV_geometry_shader_passthrough.html#NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION" class="link">Source</a> <a href="#t:NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION" class="def">NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a =&gt; a <a href="src/Vulkan.Extensions.VK_NV_geometry_shader_passthrough.html#NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION" class="link">Source</a> <a href="#v:NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME" class="def">NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME</a> = &quot;VK_NV_geometry_shader_passthrough&quot; <a href="src/Vulkan.Extensions.VK_NV_geometry_shader_passthrough.html#NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME" class="link">Source</a> <a href="#t:NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME" class="def">NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME</a> :: <span class="keyword">forall</span> a. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:IsString" title="Data.String">IsString</a> a) =&gt; a <a href="src/Vulkan.Extensions.VK_NV_geometry_shader_passthrough.html#NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME" class="link">Source</a> <a href="#v:NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>