-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utils for the vulkan package
--   
--   Utils for the vulkan package
@package vulkan-utils
@version 0.4

module Vulkan.Utils.CommandCheck

-- | Create an expression which checks the function pointers for all the
--   Vulkan commands depended upon by the specified list of function names.
--   
--   It returns a list of function names corresponding to those functions
--   with null pointers.
--   
--   Your program can use this function to fail early if a command couldn't
--   be loaded for some reason (missing extension or layer for example).
--   
--   One can create a function called <tt>checkCommands</tt> with the
--   following: <tt> [d| checkCommands = $(checkCommandsExp ['withInstance,
--   'cmdDraw, ...]) |] </tt>
--   
--   It has the type <tt>IsString a =&gt; Instance -&gt; Device -&gt;
--   [a]</tt>
--   
--   It looks basically like
--   
--   <pre>
--   inst dev -&gt;
--     [ name
--     | True &lt;- [ nullFunPtr == pVkCreateDevice inst
--               , nullFunPtr == pVkCreateFence dev
--                 ..
--               ]
--     | name &lt;- [ "vkCreateDevice"
--               , "vkCreateFence"
--                 ..
--               ]
--     ]
--   </pre>
checkCommandsExp :: [Name] -> Q Exp
instance GHC.Show.Show Vulkan.Utils.CommandCheck.DeviceOrInstanceCommand
instance GHC.Classes.Eq Vulkan.Utils.CommandCheck.DeviceOrInstanceCommand

module Vulkan.Utils.Debug

-- | A debug callback which prints the message prefixed with "Validation: "
--   to stderr.
debugCallbackPtr :: PFN_vkDebugUtilsMessengerCallbackEXT

-- | A debug callback the same as <a>debugCallbackPtr</a> except it will
--   call <tt>abort</tt> when
--   <tt>VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT</tt> is set.
debugCallbackFatalPtr :: PFN_vkDebugUtilsMessengerCallbackEXT

-- | Assign a name to a handle using <a>setDebugUtilsObjectNameEXT</a>,
--   note that the <tt>VK_EXT_debug_utils</tt> extension must be enabled.
nameObject :: (HasObjectType a, MonadIO m) => Device -> a -> ByteString -> m ()

module Vulkan.Utils.FromGL

-- | Convert an OpenGL format enum into a <a>Format</a>
--   
--   <pre>
--   &gt;&gt;&gt; internalFormat 0x8051
--   Just FORMAT_R8G8B8_UNORM
--   </pre>
internalFormat :: (Eq a, Num a) => a -> Maybe Format

module Vulkan.Utils.Misc

-- | From a list of things, take all the required things and as many
--   optional things as possible.
partitionOptReq :: Eq a => [a] -> [a] -> [a] -> ([a], Either [a] [a])

-- | Like <a>partitionOptReq</a>.
--   
--   Will throw an 'IOError in the case of missing things. Details on
--   missing things will be reported in stderr.
--   
--   This is useful in dealing with layers and extensions.
partitionOptReqIO :: (Show a, Eq a, MonadIO m) => String -> [a] -> [a] -> [a] -> m ([a], [a])

-- | Show valies as a union of their individual bits
--   
--   <pre>
--   &gt;&gt;&gt; showBits @Int 5
--   "1 .|. 4"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; showBits @Int 0
--   "zeroBits"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Vulkan.Core10.Enums.QueueFlagBits
--   
--   &gt;&gt;&gt; showBits (QUEUE_COMPUTE_BIT .|. QUEUE_GRAPHICS_BIT)
--   "QUEUE_GRAPHICS_BIT .|. QUEUE_COMPUTE_BIT"
--   </pre>
showBits :: forall a. (Show a, FiniteBits a) => a -> String

-- | Check if the intersection of bits is non-zero
(.&&.) :: Bits a => a -> a -> Bool

module Vulkan.Utils.QueueAssignment

-- | Given a <a>PhysicalDevice</a> and a set of requirements for queues,
--   calculate an assignment of queues to queue families and return
--   information with which to create a <a>Device</a> and also a function
--   to extract the requested <a>Queue</a>s from the device.
--   
--   You may want to create a custom type with a <a>Traversable</a>
--   instance to store your queues like:
--   
--   <pre>
--   data MyQueues q = MyQueues
--     { computeQueue            :: q
--     , graphicsAndPresentQueue :: q
--     , transferQueue           :: q
--     }
--   
--   myQueueSpecs :: MyQueues QueueSpec
--   myQueueSpecs = MyQueues
--     { computeQueue            = QueueSpec 0.5 isComputeQueueFamily
--     , graphicsAndPresentQueue = QueueSpec 1   isPresentQueueFamily
--     , transferQueue           = QueueSpec 1   isTransferOnlyQueueFamily
--     }
--   </pre>
--   
--   Note, this doesn't permit differentiating queue family assignment
--   based on whether or not the queue is protected.
assignQueues :: forall f m n. (Traversable f, MonadIO m, MonadIO n) => PhysicalDevice -> f (QueueSpec m) -> m (Maybe (Vector (DeviceQueueCreateInfo '[]), Device -> n (f (QueueFamilyIndex, Queue))))

-- | Requirements for a <a>Queue</a> to be assigned a family by
--   <a>assignQueues</a>.
--   
--   To assign to a specific queue family index <tt>f</tt>:
--   
--   <pre>
--   queueSpecFamilyPredicate = i _ -&gt; i == f
--   </pre>
--   
--   To assign to any queue family which supports compute operations:
--   
--   <pre>
--   let isComputeQueue q = QUEUE_COMPUTE_BIT .&amp;&amp;. queueFlags q
--   in QueueSpec priority (_index q -&gt; pure (isComputeQueue q))
--   </pre>
data QueueSpec m
QueueSpec :: Float -> (QueueFamilyIndex -> QueueFamilyProperties -> m Bool) -> QueueSpec m
[$sel:queueSpecQueuePriority:QueueSpec] :: QueueSpec m -> Float
[$sel:queueSpecFamilyPredicate:QueueSpec] :: QueueSpec m -> QueueFamilyIndex -> QueueFamilyProperties -> m Bool
newtype QueueFamilyIndex
QueueFamilyIndex :: Word32 -> QueueFamilyIndex
[$sel:unQueueFamilyIndex:QueueFamilyIndex] :: QueueFamilyIndex -> Word32
newtype QueueIndex
QueueIndex :: Word32 -> QueueIndex
[$sel:unQueueIndex:QueueIndex] :: QueueIndex -> Word32
isComputeQueueFamily :: QueueFamilyProperties -> Bool
isGraphicsQueueFamily :: QueueFamilyProperties -> Bool
isTransferQueueFamily :: QueueFamilyProperties -> Bool

-- | Does this queue have <a>QUEUE_TRANSFER_BIT</a> set and not
--   <a>QUEUE_COMPUTE_BIT</a> or <a>QUEUE_GRAPHICS_BIT</a>
isTransferOnlyQueueFamily :: QueueFamilyProperties -> Bool

-- | Can this queue family present to this surface on this device
isPresentQueueFamily :: MonadIO m => PhysicalDevice -> SurfaceKHR -> QueueFamilyIndex -> m Bool
instance GHC.Show.Show Vulkan.Utils.QueueAssignment.QueueIndex
instance GHC.Enum.Enum Vulkan.Utils.QueueAssignment.QueueIndex
instance GHC.Classes.Ord Vulkan.Utils.QueueAssignment.QueueIndex
instance GHC.Classes.Eq Vulkan.Utils.QueueAssignment.QueueIndex
instance GHC.Show.Show Vulkan.Utils.QueueAssignment.QueueFamilyIndex
instance GHC.Enum.Enum Vulkan.Utils.QueueAssignment.QueueFamilyIndex
instance GHC.Classes.Ord Vulkan.Utils.QueueAssignment.QueueFamilyIndex
instance GHC.Classes.Eq Vulkan.Utils.QueueAssignment.QueueFamilyIndex

module Vulkan.Utils.Requirements
checkInstanceRequirements :: forall m o r es. (MonadIO m, Traversable r, Traversable o) => r InstanceRequirement -> o InstanceRequirement -> InstanceCreateInfo es -> m (Maybe (InstanceCreateInfo es), r RequirementResult, o RequirementResult)
checkDeviceRequirements :: forall m o r. (MonadIO m, Traversable r, Traversable o) => r DeviceRequirement -> o DeviceRequirement -> PhysicalDevice -> DeviceCreateInfo '[] -> m (Maybe (SomeStruct DeviceCreateInfo), r RequirementResult, o RequirementResult)
data RequirementResult

-- | All the requirements were met
Satisfied :: RequirementResult

-- | Didn't attempt this check because it required
--   getPhysicalDeviceProperties2 which wasn't loaded
UnattemptedProperties :: ByteString -> RequirementResult

-- | Didn't attempt this check because it required
--   getPhysicalDeviceFeatures2 which wasn't loaded
UnattemptedFeatures :: ByteString -> RequirementResult

-- | A Layer was not found
MissingLayer :: ByteString -> RequirementResult

-- | A device version didn't meet the minimum requested
UnsatisfiedDeviceVersion :: Unsatisfied Word32 -> RequirementResult

-- | The instance version didn't meet the minimum requested
UnsatisfiedInstanceVersion :: Unsatisfied Word32 -> RequirementResult

-- | A layer version didn't meet the minimum requested
UnsatisfiedLayerVersion :: ByteString -> Unsatisfied Word32 -> RequirementResult

-- | A feature was missing
UnsatisfiedFeature :: ByteString -> RequirementResult

-- | A propery was not an appropriate value
UnsatisfiedProperty :: ByteString -> RequirementResult

-- | A device extension was missing
UnsatisfiedDeviceExtension :: ByteString -> RequirementResult

-- | An instance extension was missing
UnsatisfiedInstanceExtension :: ByteString -> RequirementResult
data Unsatisfied a
Unsatisfied :: a -> a -> Unsatisfied a

-- | The minimum value to be accepted
[$sel:unsatisfiedMinimum:Unsatisfied] :: Unsatisfied a -> a

-- | The value we got, less than <tt>unsatisfiedMinumum</tt>
[$sel:unsatisfiedActual:Unsatisfied] :: Unsatisfied a -> a

-- | Generate a string describing which requirements were not met, if
--   everything was satisfied return <a>Nothing</a>.
requirementReport :: (Foldable r, Foldable o) => r RequirementResult -> o RequirementResult -> Maybe String
prettyRequirementResult :: RequirementResult -> String
instance GHC.Classes.Ord Vulkan.Utils.Requirements.RequirementResult
instance GHC.Classes.Eq Vulkan.Utils.Requirements.RequirementResult
instance GHC.Classes.Ord a => GHC.Classes.Ord (Vulkan.Utils.Requirements.Unsatisfied a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Vulkan.Utils.Requirements.Unsatisfied a)
instance forall k (c :: k -> GHC.Types.Constraint) (a :: k). GHC.Base.Semigroup (Vulkan.Utils.Requirements.Has c a)
instance (Vulkan.Utils.Requirements.KnownChain es, Vulkan.CStruct.Extends.Extendss Vulkan.Core11.Promoted_From_VK_KHR_get_physical_device_properties2.PhysicalDeviceProperties2 es) => Vulkan.Utils.Requirements.DevicePropertyChain es
instance (Vulkan.Utils.Requirements.KnownChain es, Vulkan.CStruct.Extends.Extendss Vulkan.Core11.Promoted_From_VK_KHR_get_physical_device_properties2.PhysicalDeviceFeatures2 es, GHC.Show.Show (Vulkan.CStruct.Extends.Chain es)) => Vulkan.Utils.Requirements.DeviceFeatureChain es
instance Vulkan.Utils.Requirements.KnownChain '[]
instance (Data.Typeable.Internal.Typeable x, Vulkan.CStruct.ToCStruct x, Vulkan.CStruct.FromCStruct x, Vulkan.Utils.Requirements.KnownChain xs) => Vulkan.Utils.Requirements.KnownChain (x : xs)

module Vulkan.Utils.Initialization

-- | Create an 'Instance from some requirements.
--   
--   Will throw an 'IOError in the case of unsatisfied non-optional
--   requirements. Unsatisfied requirements will be listed on stderr.
createInstanceFromRequirements :: (MonadResource m, Extendss InstanceCreateInfo es, PokeChain es) => [InstanceRequirement] -> [InstanceRequirement] -> InstanceCreateInfo es -> m Instance

-- | Like <a>createInstanceFromRequirements</a> except it will create a
--   debug utils messenger (from the <tt>VK_EXT_debug_utils</tt>
--   extension).
--   
--   If the <tt>VK_EXT_validation_features</tt> extension (from the
--   <tt>VK_LAYER_KHRONOS_validation</tt> layer) is available is it will be
--   enabled and best practices messages enabled.
createDebugInstanceFromRequirements :: forall m es. (MonadResource m, Extendss InstanceCreateInfo es, PokeChain es) => [InstanceRequirement] -> [InstanceRequirement] -> InstanceCreateInfo es -> m Instance

-- | Create a <a>Device</a> from some requirements.
--   
--   Will throw an 'IOError in the case of unsatisfied non-optional
--   requirements. Unsatisfied requirements will be listed on stderr.
createDeviceFromRequirements :: forall m. MonadResource m => [DeviceRequirement] -> [DeviceRequirement] -> PhysicalDevice -> DeviceCreateInfo '[] -> m Device

-- | Get a single <a>PhysicalDevice</a> deciding with a scoring function
--   
--   Pass a function which will extract any required values from a device
--   in the spirit of parse-don't-validate. Also provide a function to
--   compare these results for sorting multiple suitable devices.
--   
--   As an example, the suitability function could return a tuple of device
--   memory and the compute queue family index, and the scoring function
--   could be <a>fst</a> to select devices based on their memory capacity.
--   Consider using <a>assignQueues</a> to find your desired queues in the
--   suitability function.
--   
--   Pehaps also use the functionality in <a>Requirements</a> and return
--   the <a>DeviceCreateInfo</a> too.
--   
--   If no devices are deemed suitable then a <tt>NoSuchThing</tt>
--   <a>IOError</a> is thrown.
pickPhysicalDevice :: (MonadIO m, Ord b) => Instance -> (PhysicalDevice -> m (Maybe a)) -> (a -> b) -> m (Maybe (a, PhysicalDevice))

-- | Extract the name of a <a>PhysicalDevice</a> with
--   <a>getPhysicalDeviceProperties</a>
physicalDeviceName :: MonadIO m => PhysicalDevice -> m Text

module Vulkan.Utils.Requirements.TH

-- | Parse a requirement and produce an appropriate
--   <a>DeviceRequirement</a>
--   
--   <tt>DeviceVersionRequirement</tt>s are specified by in the form
--   <tt><a>major</a>.<a>minor</a>[.<a>patch</a>]</tt>
--   
--   <tt>DeviceFeatureRequirement</tt>s are specified in the form
--   <tt><a>name</a>.&lt;member name&gt;</tt> and produce a
--   <a>RequireDeviceFeature</a> which checks and sets this feature.
--   
--   <tt>DevicePropertyRequirement</tt>s are specified like feature
--   requirements except with an additional description of the constraint.
--   This may be any of
--   
--   <ul>
--   <li><tt>myFunctioName</tt>: To check with an in-scope function taking
--   the property type and returning <a>Bool</a></li>
--   <li><tt>&gt; 123</tt>: To indicate a minimum bound on a integral
--   property</li>
--   <li><tt>&gt;= 123</tt>: To indicate an inclusive minimum bound on a
--   integral property</li>
--   <li><tt>&amp; SOMETHING_BIT</tt>: To indicate that the specified bit
--   must be present in the bitmask value</li>
--   </ul>
--   
--   <tt>DeviceExtensionRequirement</tt>s are specified in the form
--   <tt><a>name</a> <a>version</a></tt>. <tt><a>name</a></tt> must start
--   with <tt>VK_</tt>. The version will be compared against the
--   <tt>specVersion</tt> field of the <tt>ExtensionProperties</tt> record.
--   
--   <ul>
--   <li>Names may be qualified.</li>
--   <li>The separator between the type and member can be any of <tt>.</tt>
--   <tt>::</tt> <tt>:</tt> <tt>-&gt;</tt> or any amount of space</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; let r = [req|PhysicalDeviceRayTracingPipelineFeaturesKHR.rayTracingPipeline|]
--   
--   &gt;&gt;&gt; featureName r
--   "PhysicalDeviceRayTracingPipelineFeaturesKHR.rayTracingPipeline"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let r = [req|PhysicalDeviceVulkan11Features.multiview|]
--   
--   &gt;&gt;&gt; featureName r
--   "PhysicalDeviceVulkan11Features.multiview"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let r = [req|PhysicalDeviceMultiviewFeatures.multiview|]
--   
--   &gt;&gt;&gt; featureName r
--   "PhysicalDeviceMultiviewFeatures.multiview"
--   </pre>
req :: QuasiQuoter

-- | Like <a>reqs</a> except that this parses a list of newline separated
--   requirements
--   
--   It ignores
--   
--   <ul>
--   <li>Blank lines</li>
--   <li>Lines beginning with <tt>--</tt> or <tt>#</tt></li>
--   </ul>
reqs :: QuasiQuoter
instance (GHC.Show.Show qual, GHC.Show.Show unqual) => GHC.Show.Show (Vulkan.Utils.Requirements.TH.Request qual unqual)
instance Data.Traversable.Traversable Vulkan.Utils.Requirements.TH.Constraint
instance Data.Foldable.Foldable Vulkan.Utils.Requirements.TH.Constraint
instance GHC.Base.Functor Vulkan.Utils.Requirements.TH.Constraint
instance GHC.Show.Show qual => GHC.Show.Show (Vulkan.Utils.Requirements.TH.Constraint qual)

module Vulkan.Utils.ShaderQQ.Interpolate

-- | <a>interpExp</a> performs very simple interpolation of Haskell values
--   into <a>String</a>s.
--   
--   <ul>
--   <li>Interpolated variables are prefixed with <tt>$</tt></li>
--   <li>They can optionally be surrounded with braces like
--   <tt>${foo}</tt></li>
--   <li>Interpolated variables are converted to strings with
--   <a>show</a></li>
--   <li>To escape a <tt>$</tt> use <tt>\$</tt></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; let foo = 123 in $(interpExp "hello, $foo")
--   "hello, 123"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let foo = "world" in $(interpExp "hello, \\$foo")
--   "hello, $foo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let foo = "world" in $(interpExp "hello\r\n\rworld")
--   "hello\r\n\rworld"
--   </pre>
interpExp :: String -> Q Exp

module Vulkan.Utils.ShaderQQ

-- | <a>glsl</a> is a QuasiQuoter which produces GLSL source code with
--   <tt>#line</tt> directives inserted so that error locations point to
--   the correct location in the Haskell source file. It also permits basic
--   string interpolation.
--   
--   <ul>
--   <li>Interpolated variables are prefixed with <tt>$</tt></li>
--   <li>They can optionally be surrounded with braces like
--   <tt>${foo}</tt></li>
--   <li>Interpolated variables are converted to strings with
--   <a>show</a></li>
--   <li>To escape a <tt>$</tt> use <tt>\$</tt></li>
--   </ul>
--   
--   It is intended to be used in concert with <a>compileShaderQ</a> like
--   so
--   
--   <pre>
--   myConstant = 3.141 -- Note that this will have to be in a different module
--   myFragmentShader = $(compileShaderQ "frag" [glsl|
--     #version 450
--     const float myConstant = ${myConstant};
--     main (){
--     }
--   |])
--   </pre>
--   
--   An explicit example (<tt><a>interactive</a></tt> is from doctest):
--   
--   <pre>
--   &gt;&gt;&gt; let version = 450 :: Int in [glsl|#version $version|]
--   "#version 450\n#extension GL_GOOGLE_cpp_style_line_directive : enable\n#line 46 \"&lt;interactive&gt;\"\n"
--   </pre>
--   
--   Note that line number will be thrown off if any of the interpolated
--   variables contain newlines.
glsl :: QuasiQuoter

-- | QuasiQuoter for creating a compute shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "comp" [glsl|...|])</tt>
--   without interpolation support.
comp :: QuasiQuoter

-- | QuasiQuoter for creating a fragment shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "frag" [glsl|...|])</tt>
--   without interpolation support.
frag :: QuasiQuoter

-- | QuasiQuoter for creating a geometry shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "geom" [glsl|...|])</tt>
--   without interpolation support.
geom :: QuasiQuoter

-- | QuasiQuoter for creating a tessellation control shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "tesc" [glsl|...|])</tt>
--   without interpolation support.
tesc :: QuasiQuoter

-- | QuasiQuoter for creating a tessellation evaluation shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "tese" [glsl|...|])</tt>
--   without interpolation support.
tese :: QuasiQuoter

-- | QuasiQuoter for creating a vertex shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "vert" [glsl|...|])</tt>
--   without interpolation support.
vert :: QuasiQuoter
type GLSLError = String
type GLSLWarning = String

-- | Compile a glsl shader to spir-v using glslangValidator.
--   
--   Messages are converted to GHC warnings or errors depending on
--   compilation success.
compileShaderQ :: Maybe String -> String -> String -> Q Exp

-- | Compile a glsl shader to spir-v using glslangValidator
compileShader :: MonadIO m => Maybe Loc -> Maybe String -> String -> String -> m ([GLSLWarning], Either [GLSLError] ByteString)
processValidatorMessages :: ByteString -> ([GLSLWarning], [GLSLError])

module Vulkan.Utils.ShaderQQ.Shaderc

-- | <a>hlsl</a> is a QuasiQuoter which produces HLSL source code with a
--   <tt>#line</tt> directive inserted so that error locations point to the
--   correct location in the Haskell source file. It also permits basic
--   string interpolation.
--   
--   <ul>
--   <li>Interpolated variables are prefixed with <tt>$</tt></li>
--   <li>They can optionally be surrounded with braces like
--   <tt>${foo}</tt></li>
--   <li>Interpolated variables are converted to strings with
--   <a>show</a></li>
--   <li>To escape a <tt>$</tt> use <tt>\$</tt></li>
--   </ul>
--   
--   It is intended to be used in concert with <a>compileShaderQ</a> like
--   so
--   
--   <pre>
--   myConstant = 3.141 -- Note that this will have to be in a different module
--   myFragmentShader = $(compileShaderQ "frag" [hlsl|
--     static const float myConstant = ${myConstant};
--     float main (){
--       return myConstant;
--     }
--   |])
--   </pre>
--   
--   An explicit example (<tt><a>interactive</a></tt> is from doctest):
--   
--   <pre>
--   &gt;&gt;&gt; let foo = 450 :: Int in [hlsl|const float foo = $foo|]
--   "#line 31 \"&lt;interactive&gt;\"\nconst float foo = 450"
--   </pre>
--   
--   Note that line number will be thrown off if any of the interpolated
--   variables contain newlines.
hlsl :: QuasiQuoter

-- | QuasiQuoter for creating a compute shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "comp" [hlsl|...|])</tt>
--   without interpolation support.
comp :: QuasiQuoter

-- | QuasiQuoter for creating a fragment shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "frag" [hlsl|...|])</tt>
--   without interpolation support.
frag :: QuasiQuoter

-- | QuasiQuoter for creating a geometry shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "geom" [hlsl|...|])</tt>
--   without interpolation support.
geom :: QuasiQuoter

-- | QuasiQuoter for creating a tessellation control shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "tesc" [hlsl|...|])</tt>
--   without interpolation support.
tesc :: QuasiQuoter

-- | QuasiQuoter for creating a tessellation evaluation shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "tese" [hlsl|...|])</tt>
--   without interpolation support.
tese :: QuasiQuoter

-- | QuasiQuoter for creating a vertex shader.
--   
--   Equivalent to calling <tt>$(compileShaderQ "vert" [hlsl|...|])</tt>
--   without interpolation support.
vert :: QuasiQuoter
type ShadercError = String
type ShadercWarning = String

-- | Compile a HLSL shader to SPIR-V using glslc (from the shaderc project)
--   
--   Messages are converted to GHC warnings or errors depending on
--   compilation success.
compileShaderQ :: String -> String -> Q Exp

-- | Compile a HLSL shader to spir-v using glslc
compileShader :: MonadIO m => Maybe Loc -> String -> String -> m ([ShadercWarning], Either [ShadercError] ByteString)
processShadercMessages :: ByteString -> ([ShadercWarning], [ShadercError])
