<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Vulkan.Extensions.VK_KHR_external_memory</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">vulkan-3.7: Bindings to the Vulkan graphics API.</span><ul class="links" id="page-menu"><li><a href="src/Vulkan.Extensions.VK_KHR_external_memory.html">Source</a></li><li><a href="https://hackage.haskell.org/package/vulkan-3.7">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Vulkan.Extensions.VK_KHR_external_memory</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Name</h1><p>VK_KHR_external_memory - device extension</p><h2>VK_KHR_external_memory</h2><dl><dt><strong>Name String</strong></dt><dd><code>VK_KHR_external_memory</code></dd></dl><dl><dt><strong>Extension Type</strong></dt><dd>Device extension</dd><dt><strong>Registered Extension Number</strong></dt><dd>73</dd><dt><strong>Revision</strong></dt><dd>1</dd><dt><strong>Extension and Version Dependencies</strong></dt><dd><ul><li>Requires Vulkan 1.0</li><li>Requires <code>VK_KHR_external_memory_capabilities</code></li></ul></dd><dt><strong>Deprecation state</strong></dt><dd><ul><li><em>Promoted</em> to
    <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#versions-1.1-promotions">Vulkan 1.1</a></li></ul></dd><dt><strong>Contact</strong></dt><dd><ul><li>James Jones
    <a href="https://github.com/KhronosGroup/Vulkan-Docs/issues/new?title=VK_KHR_external_memory:%20&amp;body=@cubanismo%20">https://github.com/KhronosGroup/Vulkan-Docs/issues/new?title=VK_KHR_external_memory:%20&amp;body=@cubanismo%20</a></li></ul></dd></dl><h2>Other Extension Metadata</h2><dl><dt><strong>Last Modified Date</strong></dt><dd>2016-10-20</dd></dl><dl><dt><strong>IP Status</strong></dt><dd>No known IP claims.</dd><dt><strong>Interactions and External Dependencies</strong></dt><dd><ul><li>Interacts with <code>VK_KHR_dedicated_allocation</code>.</li><li>Interacts with <code>VK_NV_dedicated_allocation</code>.</li><li>Promoted to Vulkan 1.1 Core</li></ul></dd><dt><strong>Contributors</strong></dt><dd><ul><li>Jason Ekstrand, Intel</li><li>Ian Elliot, Google</li><li>Jesse Hall, Google</li><li>Tobias Hector, Imagination Technologies</li><li>James Jones, NVIDIA</li><li>Jeff Juliano, NVIDIA</li><li>Matthew Netsch, Qualcomm Technologies, Inc.</li><li>Daniel Rakos, AMD</li><li>Carsten Rohde, NVIDIA</li><li>Ray Smith, ARM</li><li>Chad Versace, Google</li></ul></dd></dl><h2>Description</h2><p>An application may wish to reference device memory in multiple Vulkan
 logical devices or instances, in multiple processes, and/or in multiple
 APIs. This extension enables an application to export non-Vulkan handles
 from Vulkan memory objects such that the underlying resources can be
 referenced outside the scope of the Vulkan logical device that created
 them.</p><h2>Promotion to Vulkan 1.1</h2><p>All functionality in this extension is included in core Vulkan 1.1, with
 the KHR suffix omitted. The original type, enum and command names are
 still available as aliases of the core functionality.</p><h2>New Structures</h2><ul><li><p>Extending <code><a href="Vulkan-Core10-Buffer.html#v:BufferCreateInfo" title="Vulkan.Core10.Buffer">BufferCreateInfo</a></code>:</p><ul><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:ExternalMemoryBufferCreateInfoKHR" title="Vulkan.Extensions.VK_KHR_external_memory">ExternalMemoryBufferCreateInfoKHR</a></code></li></ul></li></ul><ul><li><p>Extending <code><a href="Vulkan-Core10-Image.html#v:ImageCreateInfo" title="Vulkan.Core10.Image">ImageCreateInfo</a></code>:</p><ul><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:ExternalMemoryImageCreateInfoKHR" title="Vulkan.Extensions.VK_KHR_external_memory">ExternalMemoryImageCreateInfoKHR</a></code></li></ul></li><li><p>Extending <code><a href="Vulkan-Core10-Memory.html#v:MemoryAllocateInfo" title="Vulkan.Core10.Memory">MemoryAllocateInfo</a></code>:</p><ul><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:ExportMemoryAllocateInfoKHR" title="Vulkan.Extensions.VK_KHR_external_memory">ExportMemoryAllocateInfoKHR</a></code></li></ul></li></ul><h2>New Enum Constants</h2><ul><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:KHR_EXTERNAL_MEMORY_EXTENSION_NAME" title="Vulkan.Extensions.VK_KHR_external_memory">KHR_EXTERNAL_MEMORY_EXTENSION_NAME</a></code></li></ul><ul><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:KHR_EXTERNAL_MEMORY_SPEC_VERSION" title="Vulkan.Extensions.VK_KHR_external_memory">KHR_EXTERNAL_MEMORY_SPEC_VERSION</a></code></li><li><code><a href="Vulkan-Core10-APIConstants.html#v:QUEUE_FAMILY_EXTERNAL_KHR" title="Vulkan.Core10.APIConstants">QUEUE_FAMILY_EXTERNAL_KHR</a></code></li><li><p>Extending <code><a href="Vulkan-Core10-Enums-Result.html#t:Result" title="Vulkan.Core10.Enums.Result">Result</a></code>:</p><ul><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#v:ERROR_INVALID_EXTERNAL_HANDLE_KHR" title="Vulkan.Extensions.VK_KHR_external_memory">ERROR_INVALID_EXTERNAL_HANDLE_KHR</a></code></li></ul></li><li><p>Extending <code><a href="Vulkan-Core10-Enums-StructureType.html#t:StructureType" title="Vulkan.Core10.Enums.StructureType">StructureType</a></code>:</p><ul><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#v:STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" title="Vulkan.Extensions.VK_KHR_external_memory">STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR</a></code></li><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#v:STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" title="Vulkan.Extensions.VK_KHR_external_memory">STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR</a></code></li><li><code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#v:STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" title="Vulkan.Extensions.VK_KHR_external_memory">STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR</a></code></li></ul></li></ul><h2>Issues</h2><p>1) How do applications correlate two physical devices across process or
 Vulkan instance boundaries?</p><p><strong>RESOLVED</strong>: New device ID fields have been introduced by
 <code>VK_KHR_external_memory_capabilities</code>. These fields, combined with the
 existing
 <code><a href="Vulkan-Core10-DeviceInitialization.html#v:PhysicalDeviceProperties" title="Vulkan.Core10.DeviceInitialization">PhysicalDeviceProperties</a></code>::<code>driverVersion</code>
 field can be used to identify compatible devices across processes,
 drivers, and APIs.
 <code><a href="Vulkan-Core10-DeviceInitialization.html#v:PhysicalDeviceProperties" title="Vulkan.Core10.DeviceInitialization">PhysicalDeviceProperties</a></code>::<code>pipelineCacheUUID</code>
 is not sufficient for this purpose because despite its description in
 the specification, it need only identify a unique pipeline cache format
 in practice. Multiple devices may be able to use the same pipeline cache
 data, and hence it would be desirable for all of them to have the same
 pipeline cache UUID. However, only the same concrete physical device can
 be used when sharing memory, so an actual unique device ID was
 introduced. Further, the pipeline cache UUID was specific to Vulkan, but
 correlation with other, non-extensible APIs is required to enable
 interoperation with those APIs.</p><p>2) If memory objects are shared between processes and APIs, is this
 considered aliasing according to the rules outlined in the
 <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#resources-memory-aliasing">Memory Aliasing</a>
 section?</p><p><strong>RESOLVED</strong>: Yes. Applications must take care to obey all restrictions
 imposed on aliased resources when using memory across multiple Vulkan
 instances or other APIs.</p><p>3) Are new image layouts or metadata required to specify image layouts
 and layout transitions compatible with non-Vulkan APIs, or with other
 instances of the same Vulkan driver?</p><p><strong>RESOLVED</strong>: Separate instances of the same Vulkan driver running on
 the same GPU should have identical internal layout semantics, so
 applications have the tools they need to ensure views of images are
 consistent between the two instances. Other APIs will fall into two
 categories: Those that are Vulkan- compatible, and those that are
 Vulkan-incompatible. Vulkan-incompatible APIs will require the image to
 be in the GENERAL layout whenever they are accessing them.</p><p>Note this does not attempt to address cross-device transitions, nor
 transitions to engines on the same device which are not visible within
 the Vulkan API. Both of these are beyond the scope of this extension.</p><p>4) Is a new barrier flag or operation of some type needed to prepare
 external memory for handoff to another Vulkan instance or API and/or
 receive it from another instance or API?</p><p><strong>RESOLVED</strong>: Yes. Some implementations need to perform additional cache
 management when transitioning memory between address spaces, and other
 APIs, instances, or processes may operate in a separate address space.
 Options for defining this transition include:</p><ul><li>A new structure that can be added to the <code>pNext</code> list in
     <code><a href="Vulkan-Core10-OtherTypes.html#v:MemoryBarrier" title="Vulkan.Core10.OtherTypes">MemoryBarrier</a></code>,
     <code><a href="Vulkan-Core10-OtherTypes.html#v:BufferMemoryBarrier" title="Vulkan.Core10.OtherTypes">BufferMemoryBarrier</a></code>, and
     <code><a href="Vulkan-Core10-OtherTypes.html#v:ImageMemoryBarrier" title="Vulkan.Core10.OtherTypes">ImageMemoryBarrier</a></code>.</li><li>A new bit in <code><a href="Vulkan-Core10-Enums-AccessFlagBits.html#v:AccessFlags" title="Vulkan.Core10.Enums.AccessFlagBits">AccessFlags</a></code> that
     can be set to indicate an &#8220;external&#8221; access.</li><li>A new bit in
     <code><a href="Vulkan-Core10-Enums-DependencyFlagBits.html#v:DependencyFlags" title="Vulkan.Core10.Enums.DependencyFlagBits">DependencyFlags</a></code></li><li>A new special queue family that represents an &#8220;external&#8221; queue.</li></ul><p>A new structure has the advantage that the type of external transition
 can be described in as much detail as necessary. However, there is not
 currently a known need for anything beyond differentiating between
 external and internal accesses, so this is likely an over-engineered
 solution. The access flag bit has the advantage that it can be applied
 at buffer, image, or global granularity, and semantically it maps pretty
 well to the operation being described. Additionally, the API already
 includes <code><a href="Vulkan-Core10-Enums-AccessFlagBits.html#v:ACCESS_MEMORY_READ_BIT" title="Vulkan.Core10.Enums.AccessFlagBits">ACCESS_MEMORY_READ_BIT</a></code> and
 <code><a href="Vulkan-Core10-Enums-AccessFlagBits.html#v:ACCESS_MEMORY_WRITE_BIT" title="Vulkan.Core10.Enums.AccessFlagBits">ACCESS_MEMORY_WRITE_BIT</a></code> which
 appear to be intended for this purpose. However, there is no obvious
 pipeline stage that would correspond to an external access, and
 therefore no clear way to use
 <code><a href="Vulkan-Core10-Enums-AccessFlagBits.html#v:ACCESS_MEMORY_READ_BIT" title="Vulkan.Core10.Enums.AccessFlagBits">ACCESS_MEMORY_READ_BIT</a></code> or
 <code><a href="Vulkan-Core10-Enums-AccessFlagBits.html#v:ACCESS_MEMORY_WRITE_BIT" title="Vulkan.Core10.Enums.AccessFlagBits">ACCESS_MEMORY_WRITE_BIT</a></code>.
 <code><a href="Vulkan-Core10-Enums-DependencyFlagBits.html#v:DependencyFlags" title="Vulkan.Core10.Enums.DependencyFlagBits">DependencyFlags</a></code> and
 <code><a href="Vulkan-Core10-Enums-PipelineStageFlagBits.html#v:PipelineStageFlags" title="Vulkan.Core10.Enums.PipelineStageFlagBits">PipelineStageFlags</a></code> operate
 at command granularity rather than image or buffer granularity, which
 would make an entire pipeline barrier an internal&#8594;external or
 external&#8594;internal barrier. This may not be a problem in practice, but
 seems like the wrong scope. Another downside of
 <code><a href="Vulkan-Core10-Enums-DependencyFlagBits.html#v:DependencyFlags" title="Vulkan.Core10.Enums.DependencyFlagBits">DependencyFlags</a></code> is that it
 lacks inherent directionality: There are not <code>src</code> and <code>dst</code> variants of
 it in the barrier or dependency description semantics, so two bits might
 need to be added to describe both internal&#8594;external and
 external&#8594;internal transitions. Transitioning a resource to a special
 queue family corresponds well with the operation of transitioning to a
 separate Vulkan instance, in that both operations ideally include
 scheduling a barrier on both sides of the transition: Both the releasing
 and the acquiring queue or process. Using a special queue family
 requires adding an additional reserved queue family index. Re-using
 <code><a href="Vulkan-Core10-APIConstants.html#v:QUEUE_FAMILY_IGNORED" title="Vulkan.Core10.APIConstants">QUEUE_FAMILY_IGNORED</a></code> would have left it
 unclear how to transition a concurrent usage resource from one process
 to another, since the semantics would have likely been equivalent to the
 currently-ignored transition of
 <code><a href="Vulkan-Core10-APIConstants.html#v:QUEUE_FAMILY_IGNORED" title="Vulkan.Core10.APIConstants">QUEUE_FAMILY_IGNORED</a></code>&#160;&#8594;&#160;<code><a href="Vulkan-Core10-APIConstants.html#v:QUEUE_FAMILY_IGNORED" title="Vulkan.Core10.APIConstants">QUEUE_FAMILY_IGNORED</a></code>.
 Fortunately, creating a new reserved queue family index is not invasive.</p><p>Based on the above analysis, the approach of transitioning to a special
 &#8220;external&#8221; queue family was chosen.</p><p>5) Do internal driver memory arrangements and/or other internal driver
 image properties need to be exported and imported when sharing images
 across processes or APIs.</p><p><strong>RESOLVED</strong>: Some vendors claim this is necessary on their
 implementations, but it was determined that the security risks of
 allowing opaque meta data to be passed from applications to the driver
 were too high. Therefore, implementations which require metadata will
 need to associate it with the objects represented by the external
 handles, and rely on the dedicated allocation mechanism to associate the
 exported and imported memory objects with a single image or buffer.</p><p>6) Most prior interoperation and cross-process sharing APIs have been
 based on image-level sharing. Should Vulkan sharing be based on
 memory-object sharing or image sharing?</p><p><strong>RESOLVED</strong>: These extensions have assumed memory-level sharing is the
 correct granularity. Vulkan is a lower-level API than most prior APIs,
 and as such attempts to closely align with to the underlying primitives
 of the hardware and system-level drivers it abstracts. In general, the
 resource that holds the backing store for both images and buffers of
 various types is memory. Images and buffers are merely metadata
 containing brief descriptions of the layout of bits within that memory.</p><p>Because memory object-based sharing is aligned with the overall Vulkan
 API design, it exposes the full power of Vulkan on external objects.
 External memory can be used as backing for sparse images, for example,
 whereas such usage would be awkward at best with a sharing mechanism
 based on higher-level primitives such as images. Further, aligning the
 mechanism with the API in this way provides some hope of trivial
 compatibility with future API enhancements. If new objects backed by
 memory objects are added to the API, they too can be used across
 processes with minimal additions to the base external memory APIs.</p><p>Earlier APIs implemented interop at a higher level, and this
 necessitated entirely separate sharing APIs for images and buffers. To
 co-exist and interoperate with those APIs, the Vulkan external sharing
 mechanism must accommodate their model. However, if it can be agreed
 that memory-based sharing is the more desirable and forward-looking
 design, legacy interoperation considerations can be considered another
 reason to favor memory-based sharing: While native and legacy driver
 primitives that may be used to implement sharing may not be as low-level
 as the API here suggests, raw memory is still the least common
 denominator among the types. Image-based sharing can be cleanly derived
 from a set of base memory- object sharing APIs with minimal effort,
 whereas image-based sharing does not generalize well to buffer or
 raw-memory sharing. Therefore, following the general Vulkan design
 principle of minimalism, it is better to expose even interopability with
 image-based native and external primitives via the memory sharing API,
 and place sufficient limits on their usage to ensure they can be used
 only as backing for equivalent Vulkan images. This provides a consistent
 API for applications regardless of which platform or external API they
 are targeting, which makes development of multi-API and multi-platform
 applications simpler.</p><p>7) Should Vulkan define a common external handle type and provide Vulkan
 functions to facilitate cross-process sharing of such handles rather
 than relying on native handles to define the external objects?</p><p><strong>RESOLVED</strong>: No. Cross-process sharing of resources is best left to
 native platforms. There are myriad security and extensibility issues
 with such a mechanism, and attempting to re-solve all those issues
 within Vulkan does not align with Vulkan&#8217;s purpose as a graphics API. If
 desired, such a mechanism could be built as a layer or helper library on
 top of the opaque native handle defined in this family of extensions.</p><p>8) Must implementations provide additional guarantees about state
 implicitly included in memory objects for those memory objects that may
 be exported?</p><p><strong>RESOLVED</strong>: Implementations must ensure that sharing memory objects
 does not transfer any information between the exporting and importing
 instances and APIs other than that required to share the data contained
 in the memory objects explicitly shared. As specific examples, data from
 previously freed memory objects that used the same underlying physical
 memory, and data from memory obects using adjacent physical memory must
 not be visible to applications importing an exported memory object.</p><p>9) Must implementations validate external handles the application
 provides as input to memory import operations?</p><p><strong>RESOLVED</strong>: Implementations must return an error to the application if
 the provided memory handle cannot be used to complete the requested
 import operation. However, implementations need not validate handles are
 of the exact type specified by the application.</p><h2>Version History</h2><ul><li><p>Revision 1, 2016-10-20 (James Jones)</p><ul><li>Initial version</li></ul></li></ul><h1>See Also</h1><p><code><a href="Vulkan-Core10-APIConstants.html#v:QUEUE_FAMILY_EXTERNAL_KHR" title="Vulkan.Core10.APIConstants">QUEUE_FAMILY_EXTERNAL_KHR</a></code>,
 <code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:ExportMemoryAllocateInfoKHR" title="Vulkan.Extensions.VK_KHR_external_memory">ExportMemoryAllocateInfoKHR</a></code>, <code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:ExternalMemoryBufferCreateInfoKHR" title="Vulkan.Extensions.VK_KHR_external_memory">ExternalMemoryBufferCreateInfoKHR</a></code>,
 <code><a href="Vulkan-Extensions-VK_KHR_external_memory.html#t:ExternalMemoryImageCreateInfoKHR" title="Vulkan.Extensions.VK_KHR_external_memory">ExternalMemoryImageCreateInfoKHR</a></code></p><h1>Document Notes</h1><p>For more information, see the
 <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#VK_KHR_external_memory">Vulkan Specification</a></p><p>This page is a generated document. Fixes and changes should be made to
 the generator scripts, not directly.</p></div></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" class="def">STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR</a> :: <a href="Vulkan-Core10-Enums-StructureType.html#t:StructureType" title="Vulkan.Core10.Enums.StructureType">StructureType</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" class="link">Source</a> <a href="#v:STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" class="def">STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR</a> :: <a href="Vulkan-Core10-Enums-StructureType.html#t:StructureType" title="Vulkan.Core10.Enums.StructureType">StructureType</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" class="link">Source</a> <a href="#v:STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" class="def">STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR</a> :: <a href="Vulkan-Core10-Enums-StructureType.html#t:StructureType" title="Vulkan.Core10.Enums.StructureType">StructureType</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" class="link">Source</a> <a href="#v:STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:ERROR_INVALID_EXTERNAL_HANDLE_KHR" class="def">ERROR_INVALID_EXTERNAL_HANDLE_KHR</a> :: <a href="Vulkan-Core10-Enums-Result.html#t:Result" title="Vulkan.Core10.Enums.Result">Result</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#ERROR_INVALID_EXTERNAL_HANDLE_KHR" class="link">Source</a> <a href="#v:ERROR_INVALID_EXTERNAL_HANDLE_KHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:QUEUE_FAMILY_EXTERNAL_KHR" class="def">QUEUE_FAMILY_EXTERNAL_KHR</a> :: <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#QUEUE_FAMILY_EXTERNAL_KHR" class="link">Source</a> <a href="#v:QUEUE_FAMILY_EXTERNAL_KHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ExternalMemoryImageCreateInfoKHR" class="def">ExternalMemoryImageCreateInfoKHR</a> = <a href="Vulkan-Core11-Promoted_From_VK_KHR_external_memory.html#t:ExternalMemoryImageCreateInfo" title="Vulkan.Core11.Promoted_From_VK_KHR_external_memory">ExternalMemoryImageCreateInfo</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#ExternalMemoryImageCreateInfoKHR" class="link">Source</a> <a href="#t:ExternalMemoryImageCreateInfoKHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ExternalMemoryBufferCreateInfoKHR" class="def">ExternalMemoryBufferCreateInfoKHR</a> = <a href="Vulkan-Core11-Promoted_From_VK_KHR_external_memory.html#t:ExternalMemoryBufferCreateInfo" title="Vulkan.Core11.Promoted_From_VK_KHR_external_memory">ExternalMemoryBufferCreateInfo</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#ExternalMemoryBufferCreateInfoKHR" class="link">Source</a> <a href="#t:ExternalMemoryBufferCreateInfoKHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ExportMemoryAllocateInfoKHR" class="def">ExportMemoryAllocateInfoKHR</a> = <a href="Vulkan-Core11-Promoted_From_VK_KHR_external_memory.html#t:ExportMemoryAllocateInfo" title="Vulkan.Core11.Promoted_From_VK_KHR_external_memory">ExportMemoryAllocateInfo</a> <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#ExportMemoryAllocateInfoKHR" class="link">Source</a> <a href="#t:ExportMemoryAllocateInfoKHR" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:KHR_EXTERNAL_MEMORY_SPEC_VERSION" class="def">KHR_EXTERNAL_MEMORY_SPEC_VERSION</a> = 1 <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#KHR_EXTERNAL_MEMORY_SPEC_VERSION" class="link">Source</a> <a href="#t:KHR_EXTERNAL_MEMORY_SPEC_VERSION" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:KHR_EXTERNAL_MEMORY_SPEC_VERSION" class="def">KHR_EXTERNAL_MEMORY_SPEC_VERSION</a> :: <span class="keyword">forall</span> a. <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a =&gt; a <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#KHR_EXTERNAL_MEMORY_SPEC_VERSION" class="link">Source</a> <a href="#v:KHR_EXTERNAL_MEMORY_SPEC_VERSION" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:KHR_EXTERNAL_MEMORY_EXTENSION_NAME" class="def">KHR_EXTERNAL_MEMORY_EXTENSION_NAME</a> = &quot;VK_KHR_external_memory&quot; <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#KHR_EXTERNAL_MEMORY_EXTENSION_NAME" class="link">Source</a> <a href="#t:KHR_EXTERNAL_MEMORY_EXTENSION_NAME" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:KHR_EXTERNAL_MEMORY_EXTENSION_NAME" class="def">KHR_EXTERNAL_MEMORY_EXTENSION_NAME</a> :: <span class="keyword">forall</span> a. (<a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.13.0.0/docs/Data-String.html#t:IsString" title="Data.String">IsString</a> a) =&gt; a <a href="src/Vulkan.Extensions.VK_KHR_external_memory.html#KHR_EXTERNAL_MEMORY_EXTENSION_NAME" class="link">Source</a> <a href="#v:KHR_EXTERNAL_MEMORY_EXTENSION_NAME" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.23.0</p></div></body></html>