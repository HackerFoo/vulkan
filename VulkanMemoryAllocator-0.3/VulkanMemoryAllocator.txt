-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings to the VulkanMemoryAllocator library
--   
--   Bindings to the VulkanMemoryAllocator library
@package VulkanMemoryAllocator
@version 0.3

module VulkanMemoryAllocator

-- | Creates Allocator object.
createAllocator :: forall io. MonadIO io => AllocatorCreateInfo -> io Allocator

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>createAllocator</a> and <a>destroyAllocator</a>
--   
--   To ensure that <a>destroyAllocator</a> is always called: pass
--   <a>bracket</a> (or the allocate function from your favourite resource
--   management library) as the first argument. To just extract the pair
--   pass <tt>(,)</tt> as the first argument.
withAllocator :: forall io r. MonadIO io => AllocatorCreateInfo -> (io Allocator -> (Allocator -> io ()) -> r) -> r

-- | Destroys allocator object.
destroyAllocator :: forall io. MonadIO io => Allocator -> io ()

-- | Returns information about existing <a>Allocator</a> object - handle to
--   Vulkan device etc.
--   
--   It might be useful if you want to keep just the <a>Allocator</a>
--   handle and fetch other required handles to <tt>VkPhysicalDevice</tt>,
--   <tt>VkDevice</tt> etc. every time using this function.
getAllocatorInfo :: forall io. MonadIO io => Allocator -> io AllocatorInfo

-- | PhysicalDeviceProperties are fetched from physicalDevice by the
--   allocator. You can access it here, without fetching it again on your
--   own.
getPhysicalDeviceProperties :: forall io. MonadIO io => Allocator -> io (Ptr PhysicalDeviceProperties)

-- | PhysicalDeviceMemoryProperties are fetched from physicalDevice by the
--   allocator. You can access it here, without fetching it again on your
--   own.
getMemoryProperties :: forall io. MonadIO io => Allocator -> io (Ptr PhysicalDeviceMemoryProperties)

-- | Given Memory Type Index, returns Property Flags of this memory type.
--   
--   This is just a convenience function. Same information can be obtained
--   using <a>getMemoryProperties</a>.
getMemoryTypeProperties :: forall io. MonadIO io => Allocator -> ("memoryTypeIndex" ::: Word32) -> io MemoryPropertyFlags

-- | Sets index of the current frame.
--   
--   This function must be used if you make allocations with
--   <a>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> and
--   <a>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</a> flags to inform the
--   allocator when a new frame begins. Allocations queried using
--   <a>getAllocationInfo</a> cannot become lost in the current frame.
setCurrentFrameIndex :: forall io. MonadIO io => Allocator -> ("frameIndex" ::: Word32) -> io ()

-- | Retrieves statistics from current state of the Allocator.
--   
--   This function is called "calculate" not "get" because it has to
--   traverse all internal data structures, so it may be quite slow. For
--   faster but more brief statistics suitable to be called every frame or
--   every allocation, use <a>getBudget</a>.
--   
--   Note that when using allocator from multiple threads, returned
--   information may immediately become outdated.
calculateStats :: forall io. MonadIO io => Allocator -> io Stats

-- | Retrieves information about current memory budget for all memory
--   heaps.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   This function is called "get" not "calculate" because it is very fast,
--   suitable to be called every frame or every allocation. For more
--   detailed statistics use <a>calculateStats</a>.
--   
--   Note that when using allocator from multiple threads, returned
--   information may immediately become outdated.
getBudget :: forall io. MonadIO io => Allocator -> io Budget

-- | Builds and returns statistics as string in JSON format.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
buildStatsString :: forall io. MonadIO io => Allocator -> ("detailedMap" ::: Bool) -> io ("statsString" ::: Ptr CChar)
freeStatsString :: forall io. MonadIO io => Allocator -> ("statsString" ::: Ptr CChar) -> io ()

-- | Helps to find memoryTypeIndex, given memoryTypeBits and
--   <a>AllocationCreateInfo</a>.
--   
--   This algorithm tries to find a memory type that:
--   
--   <ul>
--   <li>Is allowed by memoryTypeBits.</li>
--   <li>Contains all the flags from
--   pAllocationCreateInfo-&gt;requiredFlags.</li>
--   <li>Matches intended usage.</li>
--   <li>Has as many flags from pAllocationCreateInfo-&gt;preferredFlags as
--   possible.</li>
--   </ul>
--   
--   <b>Returns.</b>
--   
--   Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such
--   result from this function or any other allocating function probably
--   means that your device doesn't support any memory type with requested
--   features for the specific type of resource you want to use it for.
--   Please check parameters of your resource, like image layout (OPTIMAL
--   versus LINEAR) or mip level count.
findMemoryTypeIndex :: forall io. MonadIO io => Allocator -> ("memoryTypeBits" ::: Word32) -> AllocationCreateInfo -> io ("memoryTypeIndex" ::: Word32)

-- | Helps to find memoryTypeIndex, given VkBufferCreateInfo and
--   <a>AllocationCreateInfo</a>.
--   
--   It can be useful e.g. to determine value to be used as
--   <i>VmaPoolCreateInfo::memoryTypeIndex</i>. It internally creates a
--   temporary, dummy buffer that never has memory bound. It is just a
--   convenience function, equivalent to calling:
--   
--   <ul>
--   <li><pre>vkCreateBuffer</pre></li>
--   <li><pre>vkGetBufferMemoryRequirements</pre></li>
--   <li><a>findMemoryTypeIndex</a></li>
--   <li><pre>vkDestroyBuffer</pre></li>
--   </ul>
findMemoryTypeIndexForBufferInfo :: forall a io. (Extendss BufferCreateInfo a, PokeChain a, MonadIO io) => Allocator -> BufferCreateInfo a -> AllocationCreateInfo -> io ("memoryTypeIndex" ::: Word32)

-- | Helps to find memoryTypeIndex, given VkImageCreateInfo and
--   <a>AllocationCreateInfo</a>.
--   
--   It can be useful e.g. to determine value to be used as
--   <i>VmaPoolCreateInfo::memoryTypeIndex</i>. It internally creates a
--   temporary, dummy image that never has memory bound. It is just a
--   convenience function, equivalent to calling:
--   
--   <ul>
--   <li><pre>vkCreateImage</pre></li>
--   <li><pre>vkGetImageMemoryRequirements</pre></li>
--   <li><a>findMemoryTypeIndex</a></li>
--   <li><pre>vkDestroyImage</pre></li>
--   </ul>
findMemoryTypeIndexForImageInfo :: forall a io. (Extendss ImageCreateInfo a, PokeChain a, MonadIO io) => Allocator -> ImageCreateInfo a -> AllocationCreateInfo -> io ("memoryTypeIndex" ::: Word32)

-- | Allocates Vulkan device memory and creates <a>Pool</a> object.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
createPool :: forall io. MonadIO io => Allocator -> PoolCreateInfo -> io Pool

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>createPool</a> and <a>destroyPool</a>
--   
--   To ensure that <a>destroyPool</a> is always called: pass
--   <a>bracket</a> (or the allocate function from your favourite resource
--   management library) as the first argument. To just extract the pair
--   pass <tt>(,)</tt> as the first argument.
withPool :: forall io r. MonadIO io => Allocator -> PoolCreateInfo -> (io Pool -> (Pool -> io ()) -> r) -> r

-- | Destroys <a>Pool</a> object and frees Vulkan device memory.
destroyPool :: forall io. MonadIO io => Allocator -> Pool -> io ()

-- | Retrieves statistics of existing <a>Pool</a> object.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
getPoolStats :: forall io. MonadIO io => Allocator -> Pool -> io PoolStats

-- | Marks all allocations in given pool as lost if they are not used in
--   current frame or <i>VmaPoolCreateInfo::frameInUseCount</i> back from
--   now.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
makePoolAllocationsLost :: forall io. MonadIO io => Allocator -> Pool -> io ("lostAllocationCount" ::: Word64)

-- | Checks magic number in margins around all allocations in given memory
--   pool in search for corruptions.
--   
--   Corruption detection is enabled only when
--   <tt>VMA_DEBUG_DETECT_CORRUPTION</tt> macro is defined to nonzero,
--   <tt>VMA_DEBUG_MARGIN</tt> is defined to nonzero and the pool is
--   created in memory type that is <tt>HOST_VISIBLE</tt> and
--   <tt>HOST_COHERENT</tt>. For more information, see <i>Corruption
--   detection</i>.
--   
--   Possible return values:
--   
--   <ul>
--   <li><tt>VK_ERROR_FEATURE_NOT_PRESENT</tt> - corruption detection is
--   not enabled for specified pool.</li>
--   <li><tt>VK_SUCCESS</tt> - corruption detection has been performed and
--   succeeded.</li>
--   <li><tt>VK_ERROR_VALIDATION_FAILED_EXT</tt> - corruption detection has
--   been performed and found memory corruptions around one of the
--   allocations. <tt>VMA_ASSERT</tt> is also fired in that case.</li>
--   <li>Other value: Error returned by Vulkan, e.g. memory mapping
--   failure.</li>
--   </ul>
checkPoolCorruption :: forall io. MonadIO io => Allocator -> Pool -> io ()

-- | Retrieves name of a custom pool.
--   
--   After the call <tt>ppName</tt> is either null or points to an
--   internally-owned null-terminated string containing name of the pool
--   that was previously set. The pointer becomes invalid when the pool is
--   destroyed or its name is changed using <a>setPoolName</a>.
getPoolName :: forall io. MonadIO io => Allocator -> Pool -> io ("name" ::: Ptr CChar)

-- | Sets name of a custom pool.
--   
--   <tt>pName</tt> can be either null or pointer to a null-terminated
--   string with new name for the pool. Function makes internal copy of the
--   string, so it can be changed or freed immediately after this call.
setPoolName :: forall io. MonadIO io => Allocator -> Pool -> ("name" ::: Maybe ByteString) -> io ()

-- | General purpose memory allocation.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   You should free the memory using <a>freeMemory</a> or
--   <a>freeMemoryPages</a>.
--   
--   It is recommended to use <a>allocateMemoryForBuffer</a>,
--   <a>allocateMemoryForImage</a>, <a>createBuffer</a>, <a>createImage</a>
--   instead whenever possible.
allocateMemory :: forall io. MonadIO io => Allocator -> ("vkMemoryRequirements" ::: MemoryRequirements) -> AllocationCreateInfo -> io (Allocation, AllocationInfo)

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>allocateMemory</a> and <a>freeMemory</a>
--   
--   To ensure that <a>freeMemory</a> is always called: pass <a>bracket</a>
--   (or the allocate function from your favourite resource management
--   library) as the first argument. To just extract the pair pass
--   <tt>(,)</tt> as the first argument.
withMemory :: forall io r. MonadIO io => Allocator -> MemoryRequirements -> AllocationCreateInfo -> (io (Allocation, AllocationInfo) -> ((Allocation, AllocationInfo) -> io ()) -> r) -> r

-- | General purpose memory allocation for multiple allocation objects at
--   once.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   You should free the memory using <a>freeMemory</a> or
--   <a>freeMemoryPages</a>.
--   
--   Word "pages" is just a suggestion to use this function to allocate
--   pieces of memory needed for sparse binding. It is just a general
--   purpose allocation function able to make multiple allocations at once.
--   It may be internally optimized to be more efficient than calling
--   <a>allocateMemory</a> <tt>allocationCount</tt> times.
--   
--   All allocations are made using same parameters. All of them are
--   created out of the same memory pool and type. If any allocation fails,
--   all allocations already made within this function call are also freed,
--   so that when returned result is not <tt>VK_SUCCESS</tt>,
--   <tt>pAllocation</tt> array is always entirely filled with
--   <tt>VK_NULL_HANDLE</tt>.
allocateMemoryPages :: forall io. MonadIO io => Allocator -> ("vkMemoryRequirements" ::: Vector MemoryRequirements) -> ("createInfo" ::: Vector AllocationCreateInfo) -> io ("allocations" ::: Vector Allocation, "allocationInfo" ::: Vector AllocationInfo)

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>allocateMemoryPages</a> and <a>freeMemoryPages</a>
--   
--   To ensure that <a>freeMemoryPages</a> is always called: pass
--   <a>bracket</a> (or the allocate function from your favourite resource
--   management library) as the first argument. To just extract the pair
--   pass <tt>(,)</tt> as the first argument.
withMemoryPages :: forall io r. MonadIO io => Allocator -> Vector MemoryRequirements -> Vector AllocationCreateInfo -> (io (Vector Allocation, Vector AllocationInfo) -> ((Vector Allocation, Vector AllocationInfo) -> io ()) -> r) -> r

-- | <b>Parameters.</b>
--   
--   TODO: table
--   
--   You should free the memory using <a>freeMemory</a>.
allocateMemoryForBuffer :: forall io. MonadIO io => Allocator -> Buffer -> AllocationCreateInfo -> io (Allocation, AllocationInfo)

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>allocateMemoryForBuffer</a> and <a>freeMemory</a>
--   
--   To ensure that <a>freeMemory</a> is always called: pass <a>bracket</a>
--   (or the allocate function from your favourite resource management
--   library) as the first argument. To just extract the pair pass
--   <tt>(,)</tt> as the first argument.
withMemoryForBuffer :: forall io r. MonadIO io => Allocator -> Buffer -> AllocationCreateInfo -> (io (Allocation, AllocationInfo) -> ((Allocation, AllocationInfo) -> io ()) -> r) -> r

-- | Function similar to <a>allocateMemoryForBuffer</a>.
allocateMemoryForImage :: forall io. MonadIO io => Allocator -> Image -> AllocationCreateInfo -> io (Allocation, AllocationInfo)

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>allocateMemoryForImage</a> and <a>freeMemory</a>
--   
--   To ensure that <a>freeMemory</a> is always called: pass <a>bracket</a>
--   (or the allocate function from your favourite resource management
--   library) as the first argument. To just extract the pair pass
--   <tt>(,)</tt> as the first argument.
withMemoryForImage :: forall io r. MonadIO io => Allocator -> Image -> AllocationCreateInfo -> (io (Allocation, AllocationInfo) -> ((Allocation, AllocationInfo) -> io ()) -> r) -> r

-- | Frees memory previously allocated using <a>allocateMemory</a>,
--   <a>allocateMemoryForBuffer</a>, or <a>allocateMemoryForImage</a>.
--   
--   Passing <tt>VK_NULL_HANDLE</tt> as <tt>allocation</tt> is valid. Such
--   function call is just skipped.
freeMemory :: forall io. MonadIO io => Allocator -> Allocation -> io ()

-- | Frees memory and destroys multiple allocations.
--   
--   Word "pages" is just a suggestion to use this function to free pieces
--   of memory used for sparse binding. It is just a general purpose
--   function to free memory and destroy allocations made using e.g.
--   <a>allocateMemory</a>, <a>allocateMemoryPages</a> and other functions.
--   It may be internally optimized to be more efficient than calling
--   <a>freeMemory</a> <tt>allocationCount</tt> times.
--   
--   Allocations in <tt>pAllocations</tt> array can come from any memory
--   pools and types. Passing <tt>VK_NULL_HANDLE</tt> as elements of
--   <tt>pAllocations</tt> array is valid. Such entries are just skipped.
freeMemoryPages :: forall io. MonadIO io => Allocator -> ("allocations" ::: Vector Allocation) -> io ()

-- | Deprecated.
--   
--   <i>Deprecated</i>
--   
--   In version 2.2.0 it used to try to change allocation's size without
--   moving or reallocating it. In current version it returns
--   <tt>VK_SUCCESS</tt> only if <tt>newSize</tt> equals current
--   allocation's size. Otherwise returns
--   <tt>VK_ERROR_OUT_OF_POOL_MEMORY</tt>, indicating that allocation's
--   size could not be changed.
resizeAllocation :: forall io. MonadIO io => Allocator -> Allocation -> ("newSize" ::: DeviceSize) -> io ()

-- | Returns current information about specified allocation and atomically
--   marks it as used in current frame.
--   
--   Current paramters of given allocation are returned in
--   <tt>pAllocationInfo</tt>.
--   
--   This function also atomically "touches" allocation - marks it as used
--   in current frame, just like <a>touchAllocation</a>. If the allocation
--   is in lost state, <tt>pAllocationInfo-&gt;deviceMemory ==
--   VK_NULL_HANDLE</tt>.
--   
--   Although this function uses atomics and doesn't lock any mutex, so it
--   should be quite efficient, you can avoid calling it too often.
--   
--   <ul>
--   <li>You can retrieve same <a>AllocationInfo</a> structure while
--   creating your resource, from function <a>createBuffer</a>,
--   <a>createImage</a>. You can remember it if you are sure parameters
--   don't change (e.g. due to defragmentation or allocation becoming
--   lost).</li>
--   <li>If you just want to check if allocation is not lost,
--   <a>touchAllocation</a> will work faster.</li>
--   </ul>
getAllocationInfo :: forall io. MonadIO io => Allocator -> Allocation -> io AllocationInfo

-- | Returns <tt>VK_TRUE</tt> if allocation is not lost and atomically
--   marks it as used in current frame.
--   
--   If the allocation has been created with
--   <a>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> flag, this function
--   returns <tt>VK_TRUE</tt> if it's not in lost state, so it can still be
--   used. It then also atomically "touches" the allocation - marks it as
--   used in current frame, so that you can be sure it won't become lost in
--   current frame or next <tt>frameInUseCount</tt> frames.
--   
--   If the allocation is in lost state, the function returns
--   <tt>VK_FALSE</tt>. Memory of such allocation, as well as buffer or
--   image bound to it, should not be used. Lost allocation and the
--   buffer/image still need to be destroyed.
--   
--   If the allocation has been created without
--   <a>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> flag, this function
--   always returns <tt>VK_TRUE</tt>.
touchAllocation :: forall io. MonadIO io => Allocator -> Allocation -> io Bool

-- | Sets pUserData in given allocation to new value.
--   
--   If the allocation was created with
--   VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT, pUserData must be
--   either null, or pointer to a null-terminated string. The function
--   makes local copy of the string and sets it as allocation's
--   <tt>pUserData</tt>. String passed as pUserData doesn't need to be
--   valid for whole lifetime of the allocation - you can free it after
--   this call. String previously pointed by allocation's pUserData is
--   freed from memory.
--   
--   If the flag was not used, the value of pointer <tt>pUserData</tt> is
--   just copied to allocation's <tt>pUserData</tt>. It is opaque, so you
--   can use it however you want - e.g. as a pointer, ordinal number or
--   some handle to you own data.
setAllocationUserData :: forall io. MonadIO io => Allocator -> Allocation -> ("userData" ::: Ptr ()) -> io ()

-- | Creates new allocation that is in lost state from the beginning.
--   
--   It can be useful if you need a dummy, non-null allocation.
--   
--   You still need to destroy created object using <a>freeMemory</a>.
--   
--   Returned allocation is not tied to any specific memory pool or memory
--   type and not bound to any image or buffer. It has size = 0. It cannot
--   be turned into a real, non-empty allocation.
createLostAllocation :: forall io. MonadIO io => Allocator -> io Allocation

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>createLostAllocation</a> and <a>freeMemory</a>
--   
--   To ensure that <a>freeMemory</a> is always called: pass <a>bracket</a>
--   (or the allocate function from your favourite resource management
--   library) as the first argument. To just extract the pair pass
--   <tt>(,)</tt> as the first argument.
withLostAllocation :: forall io r. MonadIO io => Allocator -> (io Allocation -> (Allocation -> io ()) -> r) -> r

-- | Maps memory represented by given allocation and returns pointer to it.
--   
--   Maps memory represented by given allocation to make it accessible to
--   CPU code. When succeeded, <tt>*ppData</tt> contains pointer to first
--   byte of this memory. If the allocation is part of bigger
--   <tt>VkDeviceMemory</tt> block, the pointer is correctly offseted to
--   the beginning of region assigned to this particular allocation.
--   
--   Mapping is internally reference-counted and synchronized, so despite
--   raw Vulkan function <tt>vkMapMemory()</tt> cannot be used to map same
--   block of <tt>VkDeviceMemory</tt> multiple times simultaneously, it is
--   safe to call this function on allocations assigned to the same memory
--   block. Actual Vulkan memory will be mapped on first mapping and
--   unmapped on last unmapping.
--   
--   If the function succeeded, you must call <a>unmapMemory</a> to unmap
--   the allocation when mapping is no longer needed or before freeing the
--   allocation, at the latest.
--   
--   It also safe to call this function multiple times on the same
--   allocation. You must call <a>unmapMemory</a> same number of times as
--   you called <a>mapMemory</a>.
--   
--   It is also safe to call this function on allocation created with
--   <a>ALLOCATION_CREATE_MAPPED_BIT</a> flag. Its memory stays mapped all
--   the time. You must still call <a>unmapMemory</a> same number of times
--   as you called <a>mapMemory</a>. You must not call <a>unmapMemory</a>
--   additional time to free the "0-th" mapping made automatically due to
--   <a>ALLOCATION_CREATE_MAPPED_BIT</a> flag.
--   
--   This function fails when used on allocation made in memory type that
--   is not <tt>HOST_VISIBLE</tt>.
--   
--   This function always fails when called for allocation that was created
--   with <a>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> flag. Such
--   allocations cannot be mapped.
--   
--   This function doesn't automatically flush or invalidate caches. If the
--   allocation is made from a memory types that is not
--   <tt>HOST_COHERENT</tt>, you also need to use
--   <a>invalidateAllocation</a> / <a>flushAllocation</a>, as required by
--   Vulkan specification.
mapMemory :: forall io. MonadIO io => Allocator -> Allocation -> io ("data" ::: Ptr ())

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>mapMemory</a> and <a>unmapMemory</a>
--   
--   To ensure that <a>unmapMemory</a> is always called: pass
--   <a>bracket</a> (or the allocate function from your favourite resource
--   management library) as the first argument. To just extract the pair
--   pass <tt>(,)</tt> as the first argument.
withMappedMemory :: forall io r. MonadIO io => Allocator -> Allocation -> (io (Ptr ()) -> (Ptr () -> io ()) -> r) -> r

-- | Unmaps memory represented by given allocation, mapped previously using
--   <a>mapMemory</a>.
--   
--   For details, see description of <a>mapMemory</a>.
--   
--   This function doesn't automatically flush or invalidate caches. If the
--   allocation is made from a memory types that is not
--   <tt>HOST_COHERENT</tt>, you also need to use
--   <a>invalidateAllocation</a> / <a>flushAllocation</a>, as required by
--   Vulkan specification.
unmapMemory :: forall io. MonadIO io => Allocator -> Allocation -> io ()

-- | Flushes memory of given allocation.
--   
--   Calls <tt>vkFlushMappedMemoryRanges()</tt> for memory associated with
--   given range of given allocation. It needs to be called after writing
--   to a mapped memory for memory types that are not
--   <tt>HOST_COHERENT</tt>. Unmap operation doesn't do that automatically.
--   
--   <ul>
--   <li><tt>offset</tt> must be relative to the beginning of
--   allocation.</li>
--   <li><tt>size</tt> can be <tt>VK_WHOLE_SIZE</tt>. It means all memory
--   from <tt>offset</tt> the the end of given allocation.</li>
--   <li><tt>offset</tt> and <tt>size</tt> don't have to be aligned. They
--   are internally rounded down/up to multiply of
--   <tt>nonCoherentAtomSize</tt>.</li>
--   <li>If <tt>size</tt> is 0, this call is ignored.</li>
--   <li>If memory type that the <tt>allocation</tt> belongs to is not
--   <tt>HOST_VISIBLE</tt> or it is <tt>HOST_COHERENT</tt>, this call is
--   ignored.</li>
--   </ul>
--   
--   Warning! <tt>offset</tt> and <tt>size</tt> are relative to the
--   contents of given <tt>allocation</tt>. If you mean whole allocation,
--   you can pass 0 and <tt>VK_WHOLE_SIZE</tt>, respectively. Do not pass
--   allocation's offset as <tt>offset</tt>!!!
--   
--   This function returns the <tt>VkResult</tt> from
--   <tt>vkFlushMappedMemoryRanges</tt> if it is called, otherwise
--   <tt>VK_SUCCESS</tt>.
flushAllocation :: forall io. MonadIO io => Allocator -> Allocation -> ("offset" ::: DeviceSize) -> DeviceSize -> io ()

-- | Invalidates memory of given allocation.
--   
--   Calls <tt>vkInvalidateMappedMemoryRanges()</tt> for memory associated
--   with given range of given allocation. It needs to be called before
--   reading from a mapped memory for memory types that are not
--   <tt>HOST_COHERENT</tt>. Map operation doesn't do that automatically.
--   
--   <ul>
--   <li><tt>offset</tt> must be relative to the beginning of
--   allocation.</li>
--   <li><tt>size</tt> can be <tt>VK_WHOLE_SIZE</tt>. It means all memory
--   from <tt>offset</tt> the the end of given allocation.</li>
--   <li><tt>offset</tt> and <tt>size</tt> don't have to be aligned. They
--   are internally rounded down/up to multiply of
--   <tt>nonCoherentAtomSize</tt>.</li>
--   <li>If <tt>size</tt> is 0, this call is ignored.</li>
--   <li>If memory type that the <tt>allocation</tt> belongs to is not
--   <tt>HOST_VISIBLE</tt> or it is <tt>HOST_COHERENT</tt>, this call is
--   ignored.</li>
--   </ul>
--   
--   Warning! <tt>offset</tt> and <tt>size</tt> are relative to the
--   contents of given <tt>allocation</tt>. If you mean whole allocation,
--   you can pass 0 and <tt>VK_WHOLE_SIZE</tt>, respectively. Do not pass
--   allocation's offset as <tt>offset</tt>!!!
--   
--   This function returns the <tt>VkResult</tt> from
--   <tt>vkInvalidateMappedMemoryRanges</tt> if it is called, otherwise
--   <tt>VK_SUCCESS</tt>.
invalidateAllocation :: forall io. MonadIO io => Allocator -> Allocation -> ("offset" ::: DeviceSize) -> DeviceSize -> io ()

-- | Flushes memory of given set of allocations.
--   
--   Calls <tt>vkFlushMappedMemoryRanges()</tt> for memory associated with
--   given ranges of given allocations. For more information, see
--   documentation of <a>flushAllocation</a>.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   This function returns the <tt>VkResult</tt> from
--   <tt>vkFlushMappedMemoryRanges</tt> if it is called, otherwise
--   <tt>VK_SUCCESS</tt>.
flushAllocations :: forall io. MonadIO io => Allocator -> ("allocations" ::: Vector Allocation) -> ("offsets" ::: Vector DeviceSize) -> ("sizes" ::: Vector DeviceSize) -> io ()

-- | Invalidates memory of given set of allocations.
--   
--   Calls <tt>vkInvalidateMappedMemoryRanges()</tt> for memory associated
--   with given ranges of given allocations. For more information, see
--   documentation of <a>invalidateAllocation</a>.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   This function returns the <tt>VkResult</tt> from
--   <tt>vkInvalidateMappedMemoryRanges</tt> if it is called, otherwise
--   <tt>VK_SUCCESS</tt>.
invalidateAllocations :: forall io. MonadIO io => Allocator -> ("allocations" ::: Vector Allocation) -> ("offsets" ::: Vector DeviceSize) -> ("sizes" ::: Vector DeviceSize) -> io ()

-- | Checks magic number in margins around all allocations in given memory
--   types (in both default and custom pools) in search for corruptions.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   Corruption detection is enabled only when
--   <tt>VMA_DEBUG_DETECT_CORRUPTION</tt> macro is defined to nonzero,
--   <tt>VMA_DEBUG_MARGIN</tt> is defined to nonzero and only for memory
--   types that are <tt>HOST_VISIBLE</tt> and <tt>HOST_COHERENT</tt>. For
--   more information, see <i>Corruption detection</i>.
--   
--   Possible return values:
--   
--   <ul>
--   <li><tt>VK_ERROR_FEATURE_NOT_PRESENT</tt> - corruption detection is
--   not enabled for any of specified memory types.</li>
--   <li><tt>VK_SUCCESS</tt> - corruption detection has been performed and
--   succeeded.</li>
--   <li><tt>VK_ERROR_VALIDATION_FAILED_EXT</tt> - corruption detection has
--   been performed and found memory corruptions around one of the
--   allocations. <tt>VMA_ASSERT</tt> is also fired in that case.</li>
--   <li>Other value: Error returned by Vulkan, e.g. memory mapping
--   failure.</li>
--   </ul>
checkCorruption :: forall io. MonadIO io => Allocator -> ("memoryTypeBits" ::: Word32) -> io ()

-- | Begins defragmentation process.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   <b>Returns.</b>
--   
--   <tt>VK_SUCCESS</tt> and <tt>*pContext == null</tt> if defragmentation
--   finished within this function call. <tt>VK_NOT_READY</tt> and
--   <tt>*pContext != null</tt> if defragmentation has been started and you
--   need to call <a>defragmentationEnd</a> to finish it. Negative value in
--   case of error.
--   
--   Use this function instead of old, deprecated <a>defragment</a>.
--   
--   Warning! Between the call to <a>defragmentationBegin</a> and
--   <a>defragmentationEnd</a>:
--   
--   <ul>
--   <li>You should not use any of allocations passed as
--   <tt>pInfo-&gt;pAllocations</tt> or any allocations that belong to
--   pools passed as <tt>pInfo-&gt;pPools</tt>, including calling
--   <a>getAllocationInfo</a>, <a>touchAllocation</a>, or access their
--   data.</li>
--   <li>Some mutexes protecting internal data structures may be locked, so
--   trying to make or free any allocations, bind buffers or images, map
--   memory, or launch another simultaneous defragmentation in between may
--   cause stall (when done on another thread) or deadlock (when done on
--   the same thread), unless you are 100% sure that defragmented
--   allocations are in different pools.</li>
--   <li>Information returned via <tt>pStats</tt> and
--   <tt>pInfo-&gt;pAllocationsChanged</tt> are undefined. They become
--   valid after call to <a>defragmentationEnd</a>.</li>
--   <li>If <tt>pInfo-&gt;commandBuffer</tt> is not null, you must submit
--   that command buffer and make sure it finished execution before calling
--   <a>defragmentationEnd</a>.</li>
--   </ul>
--   
--   For more information and important limitations regarding
--   defragmentation, see documentation chapter: <i>Defragmentation</i>.
defragmentationBegin :: forall io. MonadIO io => Allocator -> DefragmentationInfo2 -> io (Result, DefragmentationStats, DefragmentationContext)

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>defragmentationBegin</a> and <a>defragmentationEnd</a>
--   
--   To ensure that <a>defragmentationEnd</a> is always called: pass
--   <a>bracket</a> (or the allocate function from your favourite resource
--   management library) as the first argument. To just extract the pair
--   pass <tt>(,)</tt> as the first argument.
withDefragmentation :: forall io r. MonadIO io => Allocator -> DefragmentationInfo2 -> (io (Result, DefragmentationStats, DefragmentationContext) -> ((Result, DefragmentationStats, DefragmentationContext) -> io ()) -> r) -> r

-- | Ends defragmentation process.
--   
--   Use this function to finish defragmentation started by
--   <a>defragmentationBegin</a>. It is safe to pass <tt>context ==
--   null</tt>. The function then does nothing.
defragmentationEnd :: forall io. MonadIO io => Allocator -> DefragmentationContext -> io ()
beginDefragmentationPass :: forall io. MonadIO io => Allocator -> DefragmentationContext -> io DefragmentationPassInfo

-- | This function will call the supplied action between calls to
--   <a>beginDefragmentationPass</a> and <a>endDefragmentationPass</a>
--   
--   Note that <a>endDefragmentationPass</a> is *not* called if an
--   exception is thrown by the inner action.
useDefragmentationPass :: forall io r. MonadIO io => Allocator -> DefragmentationContext -> (DefragmentationPassInfo -> io r) -> io r
endDefragmentationPass :: forall io. MonadIO io => Allocator -> DefragmentationContext -> io ()

-- | Deprecated. Compacts memory by moving allocations.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   <b>Returns.</b>
--   
--   <tt>VK_SUCCESS</tt> if completed, negative error code in case of
--   error.
--   
--   <i>Deprecated</i>
--   
--   This is a part of the old interface. It is recommended to use
--   structure <a>DefragmentationInfo2</a> and function
--   <a>defragmentationBegin</a> instead.
--   
--   This function works by moving allocations to different places
--   (different <tt>VkDeviceMemory</tt> objects and/or different offsets)
--   in order to optimize memory usage. Only allocations that are in
--   <tt>pAllocations</tt> array can be moved. All other allocations are
--   considered nonmovable in this call. Basic rules:
--   
--   <ul>
--   <li>Only allocations made in memory types that have
--   <tt>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</tt> and
--   <tt>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</tt> flags can be compacted.
--   You may pass other allocations but it makes no sense - these will
--   never be moved.</li>
--   <li>Custom pools created with <a>POOL_CREATE_LINEAR_ALGORITHM_BIT</a>
--   or <a>POOL_CREATE_BUDDY_ALGORITHM_BIT</a> flag are not defragmented.
--   Allocations passed to this function that come from such pools are
--   ignored.</li>
--   <li>Allocations created with
--   <a>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> or created as dedicated
--   allocations for any other reason are also ignored.</li>
--   <li>Both allocations made with or without
--   <a>ALLOCATION_CREATE_MAPPED_BIT</a> flag can be compacted. If not
--   persistently mapped, memory will be mapped temporarily inside this
--   function if needed.</li>
--   <li>You must not pass same <a>Allocation</a> object multiple times in
--   <tt>pAllocations</tt> array.</li>
--   </ul>
--   
--   The function also frees empty <tt>VkDeviceMemory</tt> blocks.
--   
--   Warning: This function may be time-consuming, so you shouldn't call it
--   too often (like after every resource creation/destruction). You can
--   call it on special occasions (like when reloading a game level or when
--   you just destroyed a lot of objects). Calling it every frame may be
--   OK, but you should measure that on your platform.
--   
--   For more information, see <i>Defragmentation</i> chapter.
defragment :: forall io. MonadIO io => Allocator -> ("allocations" ::: Vector Allocation) -> ("defragmentationInfo" ::: Maybe DefragmentationInfo) -> io ("allocationsChanged" ::: Vector Bool, DefragmentationStats)

-- | Binds buffer to allocation.
--   
--   Binds specified buffer to region of memory represented by specified
--   allocation. Gets <tt>VkDeviceMemory</tt> handle and offset from the
--   allocation. If you want to create a buffer, allocate memory for it and
--   bind them together separately, you should use this function for
--   binding instead of standard <tt>vkBindBufferMemory()</tt>, because it
--   ensures proper synchronization so that when a <tt>VkDeviceMemory</tt>
--   object is used by multiple allocations, calls to
--   <tt>vkBind*Memory()</tt> or <tt>vkMapMemory()</tt> won't happen from
--   multiple threads simultaneously (which is illegal in Vulkan).
--   
--   It is recommended to use function <a>createBuffer</a> instead of this
--   one.
bindBufferMemory :: forall io. MonadIO io => Allocator -> Allocation -> Buffer -> io ()

-- | Binds buffer to allocation with additional parameters.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   This function is similar to <a>bindBufferMemory</a>, but it provides
--   additional parameters.
--   
--   If <tt>pNext</tt> is not null, <a>Allocator</a> object must have been
--   created with <a>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with
--   <i>VmaAllocatorCreateInfo::vulkanApiVersion</i> <tt>==
--   VK_API_VERSION_1_1</tt>. Otherwise the call fails.
bindBufferMemory2 :: forall io. MonadIO io => Allocator -> Allocation -> ("allocationLocalOffset" ::: DeviceSize) -> Buffer -> ("next" ::: Ptr ()) -> io ()

-- | Binds image to allocation.
--   
--   Binds specified image to region of memory represented by specified
--   allocation. Gets <tt>VkDeviceMemory</tt> handle and offset from the
--   allocation. If you want to create an image, allocate memory for it and
--   bind them together separately, you should use this function for
--   binding instead of standard <tt>vkBindImageMemory()</tt>, because it
--   ensures proper synchronization so that when a <tt>VkDeviceMemory</tt>
--   object is used by multiple allocations, calls to
--   <tt>vkBind*Memory()</tt> or <tt>vkMapMemory()</tt> won't happen from
--   multiple threads simultaneously (which is illegal in Vulkan).
--   
--   It is recommended to use function <a>createImage</a> instead of this
--   one.
bindImageMemory :: forall io. MonadIO io => Allocator -> Allocation -> Image -> io ()

-- | Binds image to allocation with additional parameters.
--   
--   <b>Parameters.</b>
--   
--   TODO: table
--   
--   This function is similar to <a>bindImageMemory</a>, but it provides
--   additional parameters.
--   
--   If <tt>pNext</tt> is not null, <a>Allocator</a> object must have been
--   created with <a>ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT</a> flag or with
--   <i>VmaAllocatorCreateInfo::vulkanApiVersion</i> <tt>==
--   VK_API_VERSION_1_1</tt>. Otherwise the call fails.
bindImageMemory2 :: forall io. MonadIO io => Allocator -> Allocation -> ("allocationLocalOffset" ::: DeviceSize) -> Image -> ("next" ::: Ptr ()) -> io ()

-- | <b>Parameters.</b>
--   
--   TODO: table
--   
--   This function automatically:
--   
--   <ol>
--   <li>Creates buffer.</li>
--   <li>Allocates appropriate memory for it.</li>
--   <li>Binds the buffer with the memory.</li>
--   </ol>
--   
--   If any of these operations fail, buffer and allocation are not
--   created, returned value is negative error code, *pBuffer and
--   *pAllocation are null.
--   
--   If the function succeeded, you must destroy both buffer and allocation
--   when you no longer need them using either convenience function
--   <a>destroyBuffer</a> or separately, using <tt>vkDestroyBuffer()</tt>
--   and <a>freeMemory</a>.
--   
--   If VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,
--   VK_KHR_dedicated_allocation extension is used internally to query
--   driver whether it requires or prefers the new buffer to have dedicated
--   allocation. If yes, and if dedicated allocation is possible
--   (<i>VmaAllocationCreateInfo::pool</i> is null and
--   VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates
--   dedicated allocation for this buffer, just like when using
--   VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
createBuffer :: forall a io. (Extendss BufferCreateInfo a, PokeChain a, MonadIO io) => Allocator -> BufferCreateInfo a -> AllocationCreateInfo -> io (Buffer, Allocation, AllocationInfo)

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>createBuffer</a> and <a>destroyBuffer</a>
--   
--   To ensure that <a>destroyBuffer</a> is always called: pass
--   <a>bracket</a> (or the allocate function from your favourite resource
--   management library) as the first argument. To just extract the pair
--   pass <tt>(,)</tt> as the first argument.
withBuffer :: forall a io r. (Extendss BufferCreateInfo a, PokeChain a, MonadIO io) => Allocator -> BufferCreateInfo a -> AllocationCreateInfo -> (io (Buffer, Allocation, AllocationInfo) -> ((Buffer, Allocation, AllocationInfo) -> io ()) -> r) -> r

-- | Destroys Vulkan buffer and frees allocated memory.
--   
--   This is just a convenience function equivalent to:
--   
--   <pre>
--   vkDestroyBuffer(device, buffer, allocationCallbacks);
--    vmaFreeMemory(allocator, allocation);
--   </pre>
--   
--   It it safe to pass null as buffer and/or allocation.
destroyBuffer :: forall io. MonadIO io => Allocator -> Buffer -> Allocation -> io ()

-- | Function similar to <a>createBuffer</a>.
createImage :: forall a io. (Extendss ImageCreateInfo a, PokeChain a, MonadIO io) => Allocator -> ImageCreateInfo a -> AllocationCreateInfo -> io (Image, Allocation, AllocationInfo)

-- | A convenience wrapper to make a compatible pair of calls to
--   <a>createImage</a> and <a>destroyImage</a>
--   
--   To ensure that <a>destroyImage</a> is always called: pass
--   <a>bracket</a> (or the allocate function from your favourite resource
--   management library) as the first argument. To just extract the pair
--   pass <tt>(,)</tt> as the first argument.
withImage :: forall a io r. (Extendss ImageCreateInfo a, PokeChain a, MonadIO io) => Allocator -> ImageCreateInfo a -> AllocationCreateInfo -> (io (Image, Allocation, AllocationInfo) -> ((Image, Allocation, AllocationInfo) -> io ()) -> r) -> r

-- | Destroys Vulkan image and frees allocated memory.
--   
--   This is just a convenience function equivalent to:
--   
--   <pre>
--   vkDestroyImage(device, image, allocationCallbacks);
--    vmaFreeMemory(allocator, allocation);
--   </pre>
--   
--   It it safe to pass null as image and/or allocation.
destroyImage :: forall io. MonadIO io => Allocator -> Image -> Allocation -> io ()

-- | VmaAllocator
--   
--   Represents main object of this library initialized.
--   
--   Fill structure <a>AllocatorCreateInfo</a> and call function
--   <a>createAllocator</a> to create it. Call function
--   <a>destroyAllocator</a> to destroy it.
--   
--   It is recommended to create just one object of this type per
--   <tt>VkDevice</tt> object, right after Vulkan is initialized and keep
--   it alive until before Vulkan device is destroyed.
newtype Allocator
Allocator :: Word64 -> Allocator
type PFN_vmaAllocateDeviceMemoryFunction = FunPtr FN_vmaAllocateDeviceMemoryFunction
type FN_vmaAllocateDeviceMemoryFunction = Allocator -> ("memoryType" ::: Word32) -> DeviceMemory -> DeviceSize -> ("pUserData" ::: Ptr ()) -> IO ()
type PFN_vmaFreeDeviceMemoryFunction = FunPtr FN_vmaFreeDeviceMemoryFunction
type FN_vmaFreeDeviceMemoryFunction = Allocator -> ("memoryType" ::: Word32) -> DeviceMemory -> DeviceSize -> ("pUserData" ::: Ptr ()) -> IO ()

-- | VmaDeviceMemoryCallbacks
--   
--   Set of callbacks that the library will call for
--   <tt>vkAllocateMemory</tt> and <tt>vkFreeMemory</tt>.
--   
--   Provided for informative purpose, e.g. to gather statistics about
--   number of allocations or total amount of memory allocated in Vulkan.
--   
--   Used in <i>VmaAllocatorCreateInfo::pDeviceMemoryCallbacks</i>.
data DeviceMemoryCallbacks
DeviceMemoryCallbacks :: PFN_vmaAllocateDeviceMemoryFunction -> PFN_vmaFreeDeviceMemoryFunction -> Ptr () -> DeviceMemoryCallbacks

-- | Optional, can be null.
[$sel:pfnAllocate:DeviceMemoryCallbacks] :: DeviceMemoryCallbacks -> PFN_vmaAllocateDeviceMemoryFunction

-- | Optional, can be null.
[$sel:pfnFree:DeviceMemoryCallbacks] :: DeviceMemoryCallbacks -> PFN_vmaFreeDeviceMemoryFunction

-- | Optional, can be null.
[$sel:userData:DeviceMemoryCallbacks] :: DeviceMemoryCallbacks -> Ptr ()

-- | Flags for created <a>Allocator</a>.
newtype AllocatorCreateFlagBits
AllocatorCreateFlagBits :: Flags -> AllocatorCreateFlagBits

-- | Allocator and all objects created from it will not be synchronized
--   internally, so you must guarantee they are used from only one thread
--   at a time or synchronized externally by you.
--   
--   Using this flag may increase performance because internal mutexes are
--   not used.
pattern ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT :: AllocatorCreateFlagBits

-- | Enables usage of VK_KHR_dedicated_allocation extension.
--   
--   The flag works only if <i>VmaAllocatorCreateInfo::vulkanApiVersion</i>
--   <tt>== VK_API_VERSION_1_0</tt>. When it's <tt>VK_API_VERSION_1_1</tt>,
--   the flag is ignored because the extension has been promoted to Vulkan
--   1.1.
--   
--   Using this extenion will automatically allocate dedicated blocks of
--   memory for some buffers and images instead of suballocating place for
--   them out of bigger memory blocks (as if you explicitly used
--   <a>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> flag) when it is
--   recommended by the driver. It may improve performance on some GPUs.
--   
--   You may set this flag only if you found out that following device
--   extensions are supported, you enabled them while creating Vulkan
--   device passed as <i>VmaAllocatorCreateInfo::device</i>, and you want
--   them to be used internally by this library:
--   
--   <ul>
--   <li>VK_KHR_get_memory_requirements2 (device extension)</li>
--   <li>VK_KHR_dedicated_allocation (device extension)</li>
--   </ul>
--   
--   When this flag is set, you can experience following warnings reported
--   by Vulkan validation layer. You can ignore them.
--   
--   vkBindBufferMemory(): Binding memory to buffer 0x2d but
--   vkGetBufferMemoryRequirements() has not been called on that buffer.
pattern ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT :: AllocatorCreateFlagBits

-- | Enables usage of VK_KHR_bind_memory2 extension.
--   
--   The flag works only if <i>VmaAllocatorCreateInfo::vulkanApiVersion</i>
--   <tt>== VK_API_VERSION_1_0</tt>. When it's <tt>VK_API_VERSION_1_1</tt>,
--   the flag is ignored because the extension has been promoted to Vulkan
--   1.1.
--   
--   You may set this flag only if you found out that this device extension
--   is supported, you enabled it while creating Vulkan device passed as
--   <i>VmaAllocatorCreateInfo::device</i>, and you want it to be used
--   internally by this library.
--   
--   The extension provides functions <tt>vkBindBufferMemory2KHR</tt> and
--   <tt>vkBindImageMemory2KHR</tt>, which allow to pass a chain of
--   <tt>pNext</tt> structures while binding. This flag is required if you
--   use <tt>pNext</tt> parameter in <a>bindBufferMemory2</a> or
--   <a>bindImageMemory2</a>.
pattern ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT :: AllocatorCreateFlagBits

-- | Enables usage of VK_EXT_memory_budget extension.
--   
--   You may set this flag only if you found out that this device extension
--   is supported, you enabled it while creating Vulkan device passed as
--   <i>VmaAllocatorCreateInfo::device</i>, and you want it to be used
--   internally by this library, along with another instance extension
--   VK_KHR_get_physical_device_properties2, which is required by it (or
--   Vulkan 1.1, where this extension is promoted).
--   
--   The extension provides query for current memory usage and budget,
--   which will probably be more accurate than an estimation used by the
--   library otherwise.
pattern ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT :: AllocatorCreateFlagBits

-- | Enables usage of VK_AMD_device_coherent_memory extension.
--   
--   You may set this flag only if you:
--   
--   <ul>
--   <li>found out that this device extension is supported and enabled it
--   while creating Vulkan device passed as
--   <i>VmaAllocatorCreateInfo::device</i>,</li>
--   <li>checked that
--   <tt>VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory</tt>
--   is true and set it while creating the Vulkan device,</li>
--   <li>want it to be used internally by this library.</li>
--   </ul>
--   
--   The extension and accompanying device feature provide access to memory
--   types with <tt>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD</tt> and
--   <tt>VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD</tt> flags. They are
--   useful mostly for writing breadcrumb markers - a common method for
--   debugging GPU crash/hang/TDR.
--   
--   When the extension is not enabled, such memory types are still
--   enumerated, but their usage is illegal. To protect from this error, if
--   you don't create the allocator with this flag, it will refuse to
--   allocate any memory or create a custom pool in such memory type,
--   returning <tt>VK_ERROR_FEATURE_NOT_PRESENT</tt>.
pattern ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT :: AllocatorCreateFlagBits

-- | Enables usage of "buffer device address" feature, which allows you to
--   use function <tt>vkGetBufferDeviceAddress*</tt> to get raw GPU pointer
--   to a buffer and pass it for usage inside a shader.
--   
--   You may set this flag only if you:
--   
--   <ol>
--   <li>(For Vulkan version &lt; 1.2) Found as available and enabled
--   device extension VK_KHR_buffer_device_address. This extension is
--   promoted to core Vulkan 1.2.</li>
--   <li>Found as available and enabled device feature
--   <tt>VkPhysicalDeviceBufferDeviceAddressFeatures*::bufferDeviceAddress</tt>.</li>
--   </ol>
--   
--   When this flag is set, you can create buffers with
--   <tt>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT*</tt> using VMA. The
--   library automatically adds
--   <tt>VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT*</tt> to allocated memory
--   blocks wherever it might be needed.
--   
--   For more information, see documentation chapter /Enabling buffer
--   device address/.
pattern ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT :: AllocatorCreateFlagBits
type AllocatorCreateFlags = AllocatorCreateFlagBits

-- | VmaVulkanFunctions
--   
--   Pointers to some Vulkan functions - a subset used by the library.
--   
--   Used in <i>VmaAllocatorCreateInfo::pVulkanFunctions</i>.
data VulkanFunctions
VulkanFunctions :: PFN_vkGetPhysicalDeviceProperties -> PFN_vkGetPhysicalDeviceMemoryProperties -> PFN_vkAllocateMemory -> PFN_vkFreeMemory -> PFN_vkMapMemory -> PFN_vkUnmapMemory -> PFN_vkFlushMappedMemoryRanges -> PFN_vkInvalidateMappedMemoryRanges -> PFN_vkBindBufferMemory -> PFN_vkBindImageMemory -> PFN_vkGetBufferMemoryRequirements -> PFN_vkGetImageMemoryRequirements -> PFN_vkCreateBuffer -> PFN_vkDestroyBuffer -> PFN_vkCreateImage -> PFN_vkDestroyImage -> PFN_vkCmdCopyBuffer -> PFN_vkGetBufferMemoryRequirements2KHR -> PFN_vkGetImageMemoryRequirements2KHR -> PFN_vkBindBufferMemory2KHR -> PFN_vkBindImageMemory2KHR -> PFN_vkGetPhysicalDeviceMemoryProperties2KHR -> VulkanFunctions
[$sel:vkGetPhysicalDeviceProperties:VulkanFunctions] :: VulkanFunctions -> PFN_vkGetPhysicalDeviceProperties
[$sel:vkGetPhysicalDeviceMemoryProperties:VulkanFunctions] :: VulkanFunctions -> PFN_vkGetPhysicalDeviceMemoryProperties
[$sel:vkAllocateMemory:VulkanFunctions] :: VulkanFunctions -> PFN_vkAllocateMemory
[$sel:vkFreeMemory:VulkanFunctions] :: VulkanFunctions -> PFN_vkFreeMemory
[$sel:vkMapMemory:VulkanFunctions] :: VulkanFunctions -> PFN_vkMapMemory
[$sel:vkUnmapMemory:VulkanFunctions] :: VulkanFunctions -> PFN_vkUnmapMemory
[$sel:vkFlushMappedMemoryRanges:VulkanFunctions] :: VulkanFunctions -> PFN_vkFlushMappedMemoryRanges
[$sel:vkInvalidateMappedMemoryRanges:VulkanFunctions] :: VulkanFunctions -> PFN_vkInvalidateMappedMemoryRanges
[$sel:vkBindBufferMemory:VulkanFunctions] :: VulkanFunctions -> PFN_vkBindBufferMemory
[$sel:vkBindImageMemory:VulkanFunctions] :: VulkanFunctions -> PFN_vkBindImageMemory
[$sel:vkGetBufferMemoryRequirements:VulkanFunctions] :: VulkanFunctions -> PFN_vkGetBufferMemoryRequirements
[$sel:vkGetImageMemoryRequirements:VulkanFunctions] :: VulkanFunctions -> PFN_vkGetImageMemoryRequirements
[$sel:vkCreateBuffer:VulkanFunctions] :: VulkanFunctions -> PFN_vkCreateBuffer
[$sel:vkDestroyBuffer:VulkanFunctions] :: VulkanFunctions -> PFN_vkDestroyBuffer
[$sel:vkCreateImage:VulkanFunctions] :: VulkanFunctions -> PFN_vkCreateImage
[$sel:vkDestroyImage:VulkanFunctions] :: VulkanFunctions -> PFN_vkDestroyImage
[$sel:vkCmdCopyBuffer:VulkanFunctions] :: VulkanFunctions -> PFN_vkCmdCopyBuffer
[$sel:vkGetBufferMemoryRequirements2KHR:VulkanFunctions] :: VulkanFunctions -> PFN_vkGetBufferMemoryRequirements2KHR
[$sel:vkGetImageMemoryRequirements2KHR:VulkanFunctions] :: VulkanFunctions -> PFN_vkGetImageMemoryRequirements2KHR
[$sel:vkBindBufferMemory2KHR:VulkanFunctions] :: VulkanFunctions -> PFN_vkBindBufferMemory2KHR
[$sel:vkBindImageMemory2KHR:VulkanFunctions] :: VulkanFunctions -> PFN_vkBindImageMemory2KHR
[$sel:vkGetPhysicalDeviceMemoryProperties2KHR:VulkanFunctions] :: VulkanFunctions -> PFN_vkGetPhysicalDeviceMemoryProperties2KHR

-- | Flags to be used in <i>VmaRecordSettings::flags</i>.
newtype RecordFlagBits
RecordFlagBits :: Flags -> RecordFlagBits

-- | Enables flush after recording every function call.
--   
--   Enable it if you expect your application to crash, which may leave
--   recording file truncated. It may degrade performance though.
pattern RECORD_FLUSH_AFTER_CALL_BIT :: RecordFlagBits
type RecordFlags = RecordFlagBits

-- | VmaRecordSettings
--   
--   Parameters for recording calls to VMA functions. To be used in
--   <i>VmaAllocatorCreateInfo::pRecordSettings</i>.
data RecordSettings
RecordSettings :: RecordFlags -> ByteString -> RecordSettings

-- | Flags for recording. Use <a>RecordFlagBits</a> enum.
[$sel:flags:RecordSettings] :: RecordSettings -> RecordFlags

-- | Path to the file that should be written by the recording.
--   
--   Suggested extension: "csv". If the file already exists, it will be
--   overwritten. It will be opened for the whole time <a>Allocator</a>
--   object is alive. If opening this file fails, creation of the whole
--   allocator object fails.
[$sel:filePath:RecordSettings] :: RecordSettings -> ByteString

-- | VmaAllocatorCreateInfo
--   
--   Description of a Allocator to be created.
data AllocatorCreateInfo
AllocatorCreateInfo :: AllocatorCreateFlags -> Ptr PhysicalDevice_T -> Ptr Device_T -> DeviceSize -> Maybe AllocationCallbacks -> Maybe DeviceMemoryCallbacks -> Word32 -> Ptr DeviceSize -> Maybe VulkanFunctions -> Maybe RecordSettings -> Ptr Instance_T -> Word32 -> AllocatorCreateInfo

-- | Flags for created allocator. Use <a>AllocatorCreateFlagBits</a> enum.
[$sel:flags:AllocatorCreateInfo] :: AllocatorCreateInfo -> AllocatorCreateFlags

-- | Vulkan physical device.
--   
--   It must be valid throughout whole lifetime of created allocator.
[$sel:physicalDevice:AllocatorCreateInfo] :: AllocatorCreateInfo -> Ptr PhysicalDevice_T

-- | Vulkan device.
--   
--   It must be valid throughout whole lifetime of created allocator.
[$sel:device:AllocatorCreateInfo] :: AllocatorCreateInfo -> Ptr Device_T

-- | Preferred size of a single <tt>VkDeviceMemory</tt> block to be
--   allocated from large heaps &gt; 1 GiB. Optional.
--   
--   Set to 0 to use default, which is currently 256 MiB.
[$sel:preferredLargeHeapBlockSize:AllocatorCreateInfo] :: AllocatorCreateInfo -> DeviceSize

-- | Custom CPU memory allocation callbacks. Optional.
--   
--   Optional, can be null. When specified, will also be used for all
--   CPU-side memory allocations.
[$sel:allocationCallbacks:AllocatorCreateInfo] :: AllocatorCreateInfo -> Maybe AllocationCallbacks

-- | Informative callbacks for <tt>vkAllocateMemory</tt>,
--   <tt>vkFreeMemory</tt>. Optional.
--   
--   Optional, can be null.
[$sel:deviceMemoryCallbacks:AllocatorCreateInfo] :: AllocatorCreateInfo -> Maybe DeviceMemoryCallbacks

-- | Maximum number of additional frames that are in use at the same time
--   as current frame.
--   
--   This value is used only when you make allocations with
--   VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot
--   become lost if allocation.lastUseFrameIndex &gt;=
--   allocator.currentFrameIndex - frameInUseCount.
--   
--   For example, if you double-buffer your command buffers, so resources
--   used for rendering in previous frame may still be in use by the GPU at
--   the moment you allocate resources needed for the current frame, set
--   this value to 1.
--   
--   If you want to allow any allocations other than used in the current
--   frame to become lost, set this value to 0.
[$sel:frameInUseCount:AllocatorCreateInfo] :: AllocatorCreateInfo -> Word32

-- | Either null or a pointer to an array of limits on maximum number of
--   bytes that can be allocated out of particular Vulkan memory heap.
--   
--   If not NULL, it must be a pointer to an array of
--   <tt>VkPhysicalDeviceMemoryProperties::memoryHeapCount</tt> elements,
--   defining limit on maximum number of bytes that can be allocated out of
--   particular Vulkan memory heap.
--   
--   Any of the elements may be equal to <tt>VK_WHOLE_SIZE</tt>, which
--   means no limit on that heap. This is also the default in case of
--   <tt>pHeapSizeLimit</tt> = NULL.
--   
--   If there is a limit defined for a heap:
--   
--   <ul>
--   <li>If user tries to allocate more memory from that heap using this
--   allocator, the allocation fails with
--   <tt>VK_ERROR_OUT_OF_DEVICE_MEMORY</tt>.</li>
--   <li>If the limit is smaller than heap size reported in
--   <tt>VkMemoryHeap::size</tt>, the value of this limit will be reported
--   instead when using <a>getMemoryProperties</a>.</li>
--   </ul>
--   
--   Warning! Using this feature may not be equivalent to installing a GPU
--   with smaller amount of memory, because graphics driver doesn't
--   necessary fail new allocations with
--   <tt>VK_ERROR_OUT_OF_DEVICE_MEMORY</tt> result when memory capacity is
--   exceeded. It may return success and just silently migrate some device
--   memory blocks to system RAM. This driver behavior can also be
--   controlled using VK_AMD_memory_overallocation_behavior extension.
[$sel:heapSizeLimit:AllocatorCreateInfo] :: AllocatorCreateInfo -> Ptr DeviceSize

-- | Pointers to Vulkan functions. Can be null.
--   
--   For details see <i>Pointers to Vulkan functions</i>.
[$sel:vulkanFunctions:AllocatorCreateInfo] :: AllocatorCreateInfo -> Maybe VulkanFunctions

-- | Parameters for recording of VMA calls. Can be null.
--   
--   If not null, it enables recording of calls to VMA functions to a file.
--   If support for recording is not enabled using
--   <tt>VMA_RECORDING_ENABLED</tt> macro, creation of the allocator object
--   fails with <tt>VK_ERROR_FEATURE_NOT_PRESENT</tt>.
[$sel:recordSettings:AllocatorCreateInfo] :: AllocatorCreateInfo -> Maybe RecordSettings

-- | Handle to Vulkan instance object.
--   
--   Starting from version 3.0.0 this member is no longer optional, it must
--   be set!
[$sel:instance':AllocatorCreateInfo] :: AllocatorCreateInfo -> Ptr Instance_T

-- | Optional. The highest version of Vulkan that the application is
--   designed to use.
--   
--   It must be a value in the format as created by macro
--   <tt>VK_MAKE_VERSION</tt> or a constant like:
--   <tt>VK_API_VERSION_1_1</tt>, <tt>VK_API_VERSION_1_0</tt>. The patch
--   version number specified is ignored. Only the major and minor versions
--   are considered. It must be less or equal (preferably equal) to value
--   as passed to <tt>vkCreateInstance</tt> as
--   <tt>VkApplicationInfo::apiVersion</tt>. Only versions 1.0 and 1.1 are
--   supported by the current implementation. Leaving it initialized to
--   zero is equivalent to <tt>VK_API_VERSION_1_0</tt>.
[$sel:vulkanApiVersion:AllocatorCreateInfo] :: AllocatorCreateInfo -> Word32

-- | VmaAllocatorInfo
--   
--   Information about existing <a>Allocator</a> object.
data AllocatorInfo
AllocatorInfo :: Ptr Instance_T -> Ptr PhysicalDevice_T -> Ptr Device_T -> AllocatorInfo

-- | Handle to Vulkan instance object.
--   
--   This is the same value as has been passed through
--   <i>VmaAllocatorCreateInfo::instance</i>.
[$sel:instance':AllocatorInfo] :: AllocatorInfo -> Ptr Instance_T

-- | Handle to Vulkan physical device object.
--   
--   This is the same value as has been passed through
--   <i>VmaAllocatorCreateInfo::physicalDevice</i>.
[$sel:physicalDevice:AllocatorInfo] :: AllocatorInfo -> Ptr PhysicalDevice_T

-- | Handle to Vulkan device object.
--   
--   This is the same value as has been passed through
--   <i>VmaAllocatorCreateInfo::device</i>.
[$sel:device:AllocatorInfo] :: AllocatorInfo -> Ptr Device_T

-- | VmaStatInfo
--   
--   Calculated statistics of memory usage in entire allocator.
data StatInfo
StatInfo :: Word32 -> Word32 -> Word32 -> DeviceSize -> DeviceSize -> DeviceSize -> DeviceSize -> DeviceSize -> DeviceSize -> DeviceSize -> DeviceSize -> StatInfo

-- | Number of <tt>VkDeviceMemory</tt> Vulkan memory blocks allocated.
[$sel:blockCount:StatInfo] :: StatInfo -> Word32

-- | Number of <a>Allocation</a> allocation objects allocated.
[$sel:allocationCount:StatInfo] :: StatInfo -> Word32

-- | Number of free ranges of memory between allocations.
[$sel:unusedRangeCount:StatInfo] :: StatInfo -> Word32

-- | Total number of bytes occupied by all allocations.
[$sel:usedBytes:StatInfo] :: StatInfo -> DeviceSize

-- | Total number of bytes occupied by unused ranges.
[$sel:unusedBytes:StatInfo] :: StatInfo -> DeviceSize
[$sel:allocationSizeMin:StatInfo] :: StatInfo -> DeviceSize
[$sel:allocationSizeAvg:StatInfo] :: StatInfo -> DeviceSize
[$sel:allocationSizeMax:StatInfo] :: StatInfo -> DeviceSize
[$sel:unusedRangeSizeMin:StatInfo] :: StatInfo -> DeviceSize
[$sel:unusedRangeSizeAvg:StatInfo] :: StatInfo -> DeviceSize
[$sel:unusedRangeSizeMax:StatInfo] :: StatInfo -> DeviceSize

-- | VmaStats
--   
--   <ul>
--   <li><a>StatInfo</a> <i>memoryType</i> [VK_MAX_MEMORY_TYPES]</li>
--   <li><a>StatInfo</a> <i>memoryHeap</i> [VK_MAX_MEMORY_HEAPS]</li>
--   <li><a>StatInfo</a> <i>total</i></li>
--   </ul>
--   
--   General statistics from current state of Allocator.
--   
--   <h3>memoryHeap</h3>
--   
--   memoryHeap VmaStats VmaStats memoryHeap <tt>VmaStatInfo
--   VmaStats::memoryHeap[VK_MAX_MEMORY_HEAPS]</tt>
--   
--   <h3>memoryType</h3>
--   
--   memoryType VmaStats VmaStats memoryType <tt>VmaStatInfo
--   VmaStats::memoryType[VK_MAX_MEMORY_TYPES]</tt>
data Stats
Stats :: Vector StatInfo -> Vector StatInfo -> StatInfo -> Stats
[$sel:memoryType:Stats] :: Stats -> Vector StatInfo
[$sel:memoryHeap:Stats] :: Stats -> Vector StatInfo
[$sel:total:Stats] :: Stats -> StatInfo

-- | VmaBudget
--   
--   Statistics of current memory usage and available budget, in bytes, for
--   specific memory heap.
data Budget
Budget :: DeviceSize -> DeviceSize -> DeviceSize -> DeviceSize -> Budget

-- | Sum size of all <tt>VkDeviceMemory</tt> blocks allocated from
--   particular heap, in bytes.
[$sel:blockBytes:Budget] :: Budget -> DeviceSize

-- | Sum size of all allocations created in particular heap, in bytes.
--   
--   Usually less or equal than <tt>blockBytes</tt>. Difference
--   <tt>blockBytes - allocationBytes</tt> is the amount of memory
--   allocated but unused - available for new allocations or wasted due to
--   fragmentation.
--   
--   It might be greater than <tt>blockBytes</tt> if there are some
--   allocations in lost state, as they account to this value as well.
[$sel:allocationBytes:Budget] :: Budget -> DeviceSize

-- | Estimated current memory usage of the program, in bytes.
--   
--   Fetched from system using <tt>VK_EXT_memory_budget</tt> extension if
--   enabled.
--   
--   It might be different than <tt>blockBytes</tt> (usually higher) due to
--   additional implicit objects also occupying the memory, like swapchain,
--   pipelines, descriptor heaps, command buffers, or
--   <tt>VkDeviceMemory</tt> blocks allocated outside of this library, if
--   any.
[$sel:usage:Budget] :: Budget -> DeviceSize

-- | Estimated amount of memory available to the program, in bytes.
--   
--   Fetched from system using <tt>VK_EXT_memory_budget</tt> extension if
--   enabled.
--   
--   It might be different (most probably smaller) than
--   <tt>VkMemoryHeap::size[heapIndex]</tt> due to factors external to the
--   program, like other programs also consuming system resources.
--   Difference <tt>budget - usage</tt> is the amount of additional memory
--   that can probably be allocated without problems. Exceeding the budget
--   may result in various problems.
[$sel:budget:Budget] :: Budget -> DeviceSize

-- | VmaPool
--   
--   Represents custom memory pool.
--   
--   Fill structure <a>PoolCreateInfo</a> and call function
--   <a>createPool</a> to create it. Call function <a>destroyPool</a> to
--   destroy it.
--   
--   For more information see <i>Custom memory pools</i>.
newtype Pool
Pool :: Word64 -> Pool
newtype MemoryUsage
MemoryUsage :: Int32 -> MemoryUsage

-- | No intended memory usage specified. Use other members of
--   <a>AllocationCreateInfo</a> to specify your requirements.
pattern MEMORY_USAGE_UNKNOWN :: MemoryUsage

-- | Memory will be used on device only, so fast access from the device is
--   preferred. It usually means device-local GPU (video) memory. No need
--   to be mappable on host. It is roughly equivalent of
--   <tt>D3D12_HEAP_TYPE_DEFAULT</tt>.
--   
--   Usage:
--   
--   <ul>
--   <li>Resources written and read by device, e.g. images used as
--   attachments.</li>
--   <li>Resources transferred from host once (immutable) or infrequently
--   and read by device multiple times, e.g. textures to be sampled, vertex
--   buffers, uniform (constant) buffers, and majority of other types of
--   resources used on GPU.</li>
--   </ul>
--   
--   Allocation may still end up in <tt>HOST_VISIBLE</tt> memory on some
--   implementations. In such case, you are free to map it. You can use
--   <a>ALLOCATION_CREATE_MAPPED_BIT</a> with this usage type.
pattern MEMORY_USAGE_GPU_ONLY :: MemoryUsage

-- | Memory will be mappable on host. It usually means CPU (system) memory.
--   Guarantees to be <tt>HOST_VISIBLE</tt> and <tt>HOST_COHERENT</tt>. CPU
--   access is typically uncached. Writes may be write-combined. Resources
--   created in this pool may still be accessible to the device, but access
--   to them can be slow. It is roughly equivalent of
--   <tt>D3D12_HEAP_TYPE_UPLOAD</tt>.
--   
--   Usage: Staging copy of resources used as transfer source.
pattern MEMORY_USAGE_CPU_ONLY :: MemoryUsage

-- | Memory that is both mappable on host (guarantees to be
--   <tt>HOST_VISIBLE</tt>) and preferably fast to access by GPU. CPU
--   access is typically uncached. Writes may be write-combined.
--   
--   Usage: Resources written frequently by host (dynamic), read by device.
--   E.g. textures, vertex buffers, uniform buffers updated every frame or
--   every draw call.
pattern MEMORY_USAGE_CPU_TO_GPU :: MemoryUsage

-- | Memory mappable on host (guarantees to be <tt>HOST_VISIBLE</tt>) and
--   cached. It is roughly equivalent of <tt>D3D12_HEAP_TYPE_READBACK</tt>.
--   
--   Usage:
--   
--   <ul>
--   <li>Resources written by device, read by host - results of some
--   computations, e.g. screen capture, average scene luminance for HDR
--   tone mapping.</li>
--   <li>Any resources read or accessed randomly on host, e.g. CPU-side
--   copy of vertex buffer used as source of transfer, but also used for
--   collision detection.</li>
--   </ul>
pattern MEMORY_USAGE_GPU_TO_CPU :: MemoryUsage

-- | CPU memory - memory that is preferably not <tt>DEVICE_LOCAL</tt>, but
--   also not guaranteed to be <tt>HOST_VISIBLE</tt>.
--   
--   Usage: Staging copy of resources moved from GPU memory to CPU memory
--   as part of custom paging/residency mechanism, to be moved back to GPU
--   memory when needed.
pattern MEMORY_USAGE_CPU_COPY :: MemoryUsage

-- | Lazily allocated GPU memory having
--   <tt>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</tt>. Exists mostly on
--   mobile platforms. Using it on desktop PC or other GPUs with no such
--   memory type present will fail the allocation.
--   
--   Usage: Memory for transient attachment images (color attachments,
--   depth attachments etc.), created with
--   <tt>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</tt>.
--   
--   Allocations with this usage are always created as dedicated - it
--   implies <a>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a>.
pattern MEMORY_USAGE_GPU_LAZILY_ALLOCATED :: MemoryUsage

-- | Flags to be passed as <i>VmaAllocationCreateInfo::flags</i>.
newtype AllocationCreateFlagBits
AllocationCreateFlagBits :: Flags -> AllocationCreateFlagBits

-- | Set this flag if the allocation should have its own memory block.
--   
--   Use it for special, big resources, like fullscreen images used as
--   attachments.
--   
--   You should not use this flag if <i>VmaAllocationCreateInfo::pool</i>
--   is not null.
pattern ALLOCATION_CREATE_DEDICATED_MEMORY_BIT :: AllocationCreateFlagBits

-- | Set this flag to only try to allocate from existing
--   <tt>VkDeviceMemory</tt> blocks and never create new such block.
--   
--   If new allocation cannot be placed in any of the existing blocks,
--   allocation fails with <tt>VK_ERROR_OUT_OF_DEVICE_MEMORY</tt> error.
--   
--   You should not use <a>ALLOCATION_CREATE_DEDICATED_MEMORY_BIT</a> and
--   <a>ALLOCATION_CREATE_NEVER_ALLOCATE_BIT</a> at the same time. It makes
--   no sense.
--   
--   If <i>VmaAllocationCreateInfo::pool</i> is not null, this flag is
--   implied and ignored.
pattern ALLOCATION_CREATE_NEVER_ALLOCATE_BIT :: AllocationCreateFlagBits

-- | Set this flag to use a memory that will be persistently mapped and
--   retrieve pointer to it.
--   
--   Pointer to mapped memory will be returned through
--   <i>VmaAllocationInfo::pMappedData</i>.
--   
--   Is it valid to use this flag for allocation made from memory type that
--   is not <tt>HOST_VISIBLE</tt>. This flag is then ignored and memory is
--   not mapped. This is useful if you need an allocation that is efficient
--   to use on GPU (<tt>DEVICE_LOCAL</tt>) and still want to map it
--   directly if possible on platforms that support it (e.g. Intel GPU).
--   
--   You should not use this flag together with
--   <a>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a>.
pattern ALLOCATION_CREATE_MAPPED_BIT :: AllocationCreateFlagBits

-- | Allocation created with this flag can become lost as a result of
--   another allocation with
--   <a>ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT</a> flag, so you must
--   check it before use.
--   
--   To check if allocation is not lost, call <a>getAllocationInfo</a> and
--   check if <i>VmaAllocationInfo::deviceMemory</i> is not
--   <tt>VK_NULL_HANDLE</tt>.
--   
--   For details about supporting lost allocations, see Lost Allocations
--   chapter of User Guide on Main Page.
--   
--   You should not use this flag together with
--   <a>ALLOCATION_CREATE_MAPPED_BIT</a>.
pattern ALLOCATION_CREATE_CAN_BECOME_LOST_BIT :: AllocationCreateFlagBits

-- | While creating allocation using this flag, other allocations that were
--   created with flag <a>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> can
--   become lost.
--   
--   For details about supporting lost allocations, see Lost Allocations
--   chapter of User Guide on Main Page.
pattern ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT :: AllocationCreateFlagBits

-- | Set this flag to treat <i>VmaAllocationCreateInfo::pUserData</i> as
--   pointer to a null-terminated string. Instead of copying pointer value,
--   a local copy of the string is made and stored in allocation's
--   <tt>pUserData</tt>. The string is automatically freed together with
--   the allocation. It is also used in <a>buildStatsString</a>.
pattern ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT :: AllocationCreateFlagBits

-- | Allocation will be created from upper stack in a double stack pool.
--   
--   This flag is only allowed for custom pools created with
--   <a>POOL_CREATE_LINEAR_ALGORITHM_BIT</a> flag.
pattern ALLOCATION_CREATE_UPPER_ADDRESS_BIT :: AllocationCreateFlagBits

-- | Create both buffer/image and allocation, but don't bind them together.
--   It is useful when you want to bind yourself to do some more advanced
--   binding, e.g. using some extensions. The flag is meaningful only with
--   functions that bind by default: <a>createBuffer</a>,
--   <a>createImage</a>. Otherwise it is ignored.
pattern ALLOCATION_CREATE_DONT_BIND_BIT :: AllocationCreateFlagBits

-- | Create allocation only if additional device memory required for it, if
--   any, won't exceed memory budget. Otherwise return
--   <tt>VK_ERROR_OUT_OF_DEVICE_MEMORY</tt>.
pattern ALLOCATION_CREATE_WITHIN_BUDGET_BIT :: AllocationCreateFlagBits

-- | Allocation strategy that chooses smallest possible free range for the
--   allocation.
pattern ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT :: AllocationCreateFlagBits

-- | Allocation strategy that chooses biggest possible free range for the
--   allocation.
pattern ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT :: AllocationCreateFlagBits

-- | Allocation strategy that chooses first suitable free range for the
--   allocation.
--   
--   "First" doesn't necessarily means the one with smallest offset in
--   memory, but rather the one that is easiest and fastest to find.
pattern ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT :: AllocationCreateFlagBits

-- | Allocation strategy that tries to minimize memory usage.
pattern ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT :: AllocationCreateFlagBits

-- | Allocation strategy that tries to minimize allocation time.
pattern ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT :: AllocationCreateFlagBits

-- | Allocation strategy that tries to minimize memory fragmentation.
pattern ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT :: AllocationCreateFlagBits

-- | A bit mask to extract only <tt>STRATEGY</tt> bits from entire set of
--   flags.
pattern ALLOCATION_CREATE_STRATEGY_MASK :: AllocationCreateFlagBits
type AllocationCreateFlags = AllocationCreateFlagBits

-- | VmaAllocationCreateInfo
data AllocationCreateInfo
AllocationCreateInfo :: AllocationCreateFlags -> MemoryUsage -> MemoryPropertyFlags -> MemoryPropertyFlags -> Word32 -> Pool -> Ptr () -> AllocationCreateInfo

-- | Use <a>AllocationCreateFlagBits</a> enum.
[$sel:flags:AllocationCreateInfo] :: AllocationCreateInfo -> AllocationCreateFlags

-- | Intended usage of memory.
--   
--   You can leave <a>MEMORY_USAGE_UNKNOWN</a> if you specify memory
--   requirements in other way. If <tt>pool</tt> is not null, this member
--   is ignored.
[$sel:usage:AllocationCreateInfo] :: AllocationCreateInfo -> MemoryUsage

-- | Flags that must be set in a Memory Type chosen for an allocation.
--   
--   Leave 0 if you specify memory requirements in other way. If
--   <tt>pool</tt> is not null, this member is ignored.
[$sel:requiredFlags:AllocationCreateInfo] :: AllocationCreateInfo -> MemoryPropertyFlags

-- | Flags that preferably should be set in a memory type chosen for an
--   allocation.
--   
--   Set to 0 if no additional flags are prefered. If <tt>pool</tt> is not
--   null, this member is ignored.
[$sel:preferredFlags:AllocationCreateInfo] :: AllocationCreateInfo -> MemoryPropertyFlags

-- | Bitmask containing one bit set for every memory type acceptable for
--   this allocation.
--   
--   Value 0 is equivalent to <tt>UINT32_MAX</tt> - it means any memory
--   type is accepted if it meets other requirements specified by this
--   structure, with no further restrictions on memory type index. If
--   <tt>pool</tt> is not null, this member is ignored.
[$sel:memoryTypeBits:AllocationCreateInfo] :: AllocationCreateInfo -> Word32

-- | Pool that this allocation should be created in.
--   
--   Leave <tt>VK_NULL_HANDLE</tt> to allocate from default pool. If not
--   null, members: <tt>usage</tt>, <tt>requiredFlags</tt>,
--   <tt>preferredFlags</tt>, <tt>memoryTypeBits</tt> are ignored.
[$sel:pool:AllocationCreateInfo] :: AllocationCreateInfo -> Pool

-- | Custom general-purpose pointer that will be stored in
--   <a>Allocation</a>, can be read as <i>VmaAllocationInfo::pUserData</i>
--   and changed using <a>setAllocationUserData</a>.
--   
--   If <a>ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT</a> is used, it must
--   be either null or pointer to a null-terminated string. The string will
--   be then copied to internal buffer, so it doesn't need to be valid
--   after allocation call.
[$sel:userData:AllocationCreateInfo] :: AllocationCreateInfo -> Ptr ()

-- | Flags to be passed as <i>VmaPoolCreateInfo::flags</i>.
newtype PoolCreateFlagBits
PoolCreateFlagBits :: Flags -> PoolCreateFlagBits

-- | Use this flag if you always allocate only buffers and linear images or
--   only optimal images out of this pool and so Buffer-Image Granularity
--   can be ignored.
--   
--   This is an optional optimization flag.
--   
--   If you always allocate using <a>createBuffer</a>, <a>createImage</a>,
--   <a>allocateMemoryForBuffer</a>, then you don't need to use it because
--   allocator knows exact type of your allocations so it can handle
--   Buffer-Image Granularity in the optimal way.
--   
--   If you also allocate using <a>allocateMemoryForImage</a> or
--   <a>allocateMemory</a>, exact type of such allocations is not known, so
--   allocator must be conservative in handling Buffer-Image Granularity,
--   which can lead to suboptimal allocation (wasted memory). In that case,
--   if you can make sure you always allocate only buffers and linear
--   images or only optimal images out of this pool, use this flag to make
--   allocator disregard Buffer-Image Granularity and so make allocations
--   faster and more optimal.
pattern POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT :: PoolCreateFlagBits

-- | Enables alternative, linear allocation algorithm in this pool.
--   
--   Specify this flag to enable linear allocation algorithm, which always
--   creates new allocations after last one and doesn't reuse space from
--   allocations freed in between. It trades memory consumption for
--   simplified algorithm and data structure, which has better performance
--   and uses less memory for metadata.
--   
--   By using this flag, you can achieve behavior of free-at-once, stack,
--   ring buffer, and double stack. For details, see documentation chapter
--   <i>Linear allocation algorithm</i>.
--   
--   When using this flag, you must specify
--   <i>VmaPoolCreateInfo::maxBlockCount</i> == 1 (or 0 for default).
--   
--   For more details, see <i>Linear allocation algorithm</i>.
pattern POOL_CREATE_LINEAR_ALGORITHM_BIT :: PoolCreateFlagBits

-- | Enables alternative, buddy allocation algorithm in this pool.
--   
--   It operates on a tree of blocks, each having size that is a power of
--   two and a half of its parent's size. Comparing to default algorithm,
--   this one provides faster allocation and deallocation and decreased
--   external fragmentation, at the expense of more memory wasted (internal
--   fragmentation).
--   
--   For more details, see <i>Buddy allocation algorithm</i>.
pattern POOL_CREATE_BUDDY_ALGORITHM_BIT :: PoolCreateFlagBits

-- | Bit mask to extract only <tt>ALGORITHM</tt> bits from entire set of
--   flags.
pattern POOL_CREATE_ALGORITHM_MASK :: PoolCreateFlagBits
type PoolCreateFlags = PoolCreateFlagBits

-- | VmaPoolCreateInfo
--   
--   Describes parameter of created <a>Pool</a>.
data PoolCreateInfo
PoolCreateInfo :: Word32 -> PoolCreateFlags -> DeviceSize -> Word64 -> Word64 -> Word32 -> PoolCreateInfo

-- | Vulkan memory type index to allocate this pool from.
[$sel:memoryTypeIndex:PoolCreateInfo] :: PoolCreateInfo -> Word32

-- | Use combination of <a>PoolCreateFlagBits</a>.
[$sel:flags:PoolCreateInfo] :: PoolCreateInfo -> PoolCreateFlags

-- | Size of a single <tt>VkDeviceMemory</tt> block to be allocated as part
--   of this pool, in bytes. Optional.
--   
--   Specify nonzero to set explicit, constant size of memory blocks used
--   by this pool.
--   
--   Leave 0 to use default and let the library manage block sizes
--   automatically. Sizes of particular blocks may vary.
[$sel:blockSize:PoolCreateInfo] :: PoolCreateInfo -> DeviceSize

-- | Minimum number of blocks to be always allocated in this pool, even if
--   they stay empty.
--   
--   Set to 0 to have no preallocated blocks and allow the pool be
--   completely empty.
[$sel:minBlockCount:PoolCreateInfo] :: PoolCreateInfo -> Word64

-- | Maximum number of blocks that can be allocated in this pool. Optional.
--   
--   Set to 0 to use default, which is <tt>SIZE_MAX</tt>, which means no
--   limit.
--   
--   Set to same value as <i>VmaPoolCreateInfo::minBlockCount</i> to have
--   fixed amount of memory allocated throughout whole lifetime of this
--   pool.
[$sel:maxBlockCount:PoolCreateInfo] :: PoolCreateInfo -> Word64

-- | Maximum number of additional frames that are in use at the same time
--   as current frame.
--   
--   This value is used only when you make allocations with
--   <a>ALLOCATION_CREATE_CAN_BECOME_LOST_BIT</a> flag. Such allocation
--   cannot become lost if allocation.lastUseFrameIndex &gt;=
--   allocator.currentFrameIndex - frameInUseCount.
--   
--   For example, if you double-buffer your command buffers, so resources
--   used for rendering in previous frame may still be in use by the GPU at
--   the moment you allocate resources needed for the current frame, set
--   this value to 1.
--   
--   If you want to allow any allocations other than used in the current
--   frame to become lost, set this value to 0.
[$sel:frameInUseCount:PoolCreateInfo] :: PoolCreateInfo -> Word32

-- | VmaPoolStats
--   
--   Describes parameter of existing <a>Pool</a>.
data PoolStats
PoolStats :: DeviceSize -> DeviceSize -> Word64 -> Word64 -> DeviceSize -> Word64 -> PoolStats

-- | Total amount of <tt>VkDeviceMemory</tt> allocated from Vulkan for this
--   pool, in bytes.
[$sel:size:PoolStats] :: PoolStats -> DeviceSize

-- | Total number of bytes in the pool not used by any <a>Allocation</a>.
[$sel:unusedSize:PoolStats] :: PoolStats -> DeviceSize

-- | Number of <a>Allocation</a> objects created from this pool that were
--   not destroyed or lost.
[$sel:allocationCount:PoolStats] :: PoolStats -> Word64

-- | Number of continuous memory ranges in the pool not used by any
--   <a>Allocation</a>.
[$sel:unusedRangeCount:PoolStats] :: PoolStats -> Word64

-- | Size of the largest continuous free memory region available for new
--   allocation.
--   
--   Making a new allocation of that size is not guaranteed to succeed
--   because of possible additional margin required to respect alignment
--   and buffer/image granularity.
[$sel:unusedRangeSizeMax:PoolStats] :: PoolStats -> DeviceSize

-- | Number of <tt>VkDeviceMemory</tt> blocks allocated for this pool.
[$sel:blockCount:PoolStats] :: PoolStats -> Word64

-- | VmaAllocation
--   
--   Represents single memory allocation.
--   
--   It may be either dedicated block of <tt>VkDeviceMemory</tt> or a
--   specific region of a bigger block of this type plus unique offset.
--   
--   There are multiple ways to create such object. You need to fill
--   structure <a>AllocationCreateInfo</a>. For more information see
--   /Choosing memory type/.
--   
--   Although the library provides convenience functions that create Vulkan
--   buffer or image, allocate memory for it and bind them together,
--   binding of the allocation to a buffer or an image is out of scope of
--   the allocation itself. Allocation object can exist without
--   buffer/image bound, binding can be done manually by the user, and
--   destruction of it can be done independently of destruction of the
--   allocation.
--   
--   The object also remembers its size and some other information. To
--   retrieve this information, use function <a>getAllocationInfo</a> and
--   inspect returned structure <a>AllocationInfo</a>.
--   
--   Some kinds allocations can be in lost state. For more information, see
--   <i>Lost allocations</i>.
newtype Allocation
Allocation :: Word64 -> Allocation

-- | VmaAllocationInfo
--   
--   Parameters of <a>Allocation</a> objects, that can be retrieved using
--   function <a>getAllocationInfo</a>.
data AllocationInfo
AllocationInfo :: Word32 -> DeviceMemory -> DeviceSize -> DeviceSize -> Ptr () -> Ptr () -> AllocationInfo

-- | Memory type index that this allocation was allocated from.
--   
--   It never changes.
[$sel:memoryType:AllocationInfo] :: AllocationInfo -> Word32

-- | Handle to Vulkan memory object.
--   
--   Same memory object can be shared by multiple allocations.
--   
--   It can change after call to <a>defragment</a> if this allocation is
--   passed to the function, or if allocation is lost.
--   
--   If the allocation is lost, it is equal to <tt>VK_NULL_HANDLE</tt>.
[$sel:deviceMemory:AllocationInfo] :: AllocationInfo -> DeviceMemory

-- | Offset into deviceMemory object to the beginning of this allocation,
--   in bytes. (deviceMemory, offset) pair is unique to this allocation.
--   
--   It can change after call to <a>defragment</a> if this allocation is
--   passed to the function, or if allocation is lost.
[$sel:offset:AllocationInfo] :: AllocationInfo -> DeviceSize

-- | Size of this allocation, in bytes.
--   
--   It never changes, unless allocation is lost.
[$sel:size:AllocationInfo] :: AllocationInfo -> DeviceSize

-- | Pointer to the beginning of this allocation as mapped data.
--   
--   If the allocation hasn't been mapped using <a>mapMemory</a> and hasn't
--   been created with <a>ALLOCATION_CREATE_MAPPED_BIT</a> flag, this value
--   is null.
--   
--   It can change after call to <a>mapMemory</a>, <a>unmapMemory</a>. It
--   can also change after call to <a>defragment</a> if this allocation is
--   passed to the function.
[$sel:mappedData:AllocationInfo] :: AllocationInfo -> Ptr ()

-- | Custom general-purpose pointer that was passed as
--   <i>VmaAllocationCreateInfo::pUserData</i> or set using
--   <a>setAllocationUserData</a>.
--   
--   It can change after call to <a>setAllocationUserData</a> for this
--   allocation.
[$sel:userData:AllocationInfo] :: AllocationInfo -> Ptr ()

-- | VmaDefragmentationContext
--   
--   Represents Opaque object that represents started defragmentation
--   process.
--   
--   Fill structure <a>DefragmentationInfo2</a> and call function
--   <a>defragmentationBegin</a> to create it. Call function
--   <a>defragmentationEnd</a> to destroy it.
newtype DefragmentationContext
DefragmentationContext :: Word64 -> DefragmentationContext

-- | Flags to be used in <a>defragmentationBegin</a>. None at the moment.
--   Reserved for future use.
newtype DefragmentationFlagBits
DefragmentationFlagBits :: Flags -> DefragmentationFlagBits
pattern DEFRAGMENTATION_FLAG_INCREMENTAL :: DefragmentationFlagBits
type DefragmentationFlags = DefragmentationFlagBits

-- | VmaDefragmentationInfo2
--   
--   Parameters for defragmentation.
--   
--   To be used with function <a>defragmentationBegin</a>.
data DefragmentationInfo2
DefragmentationInfo2 :: DefragmentationFlags -> Vector Allocation -> Ptr Bool32 -> Vector Pool -> DeviceSize -> Word32 -> DeviceSize -> Word32 -> Ptr CommandBuffer_T -> DefragmentationInfo2

-- | Reserved for future use. Should be 0.
[$sel:flags:DefragmentationInfo2] :: DefragmentationInfo2 -> DefragmentationFlags

-- | Pointer to array of allocations that can be defragmented.
--   
--   The array should have <tt>allocationCount</tt> elements. The array
--   should not contain nulls. Elements in the array should be unique -
--   same allocation cannot occur twice. It is safe to pass allocations
--   that are in the lost state - they are ignored. All allocations not
--   present in this array are considered non-moveable during this
--   defragmentation.
[$sel:allocations:DefragmentationInfo2] :: DefragmentationInfo2 -> Vector Allocation

-- | Optional, output. Pointer to array that will be filled with
--   information whether the allocation at certain index has been changed
--   during defragmentation.
--   
--   The array should have <tt>allocationCount</tt> elements. You can pass
--   null if you are not interested in this information.
[$sel:allocationsChanged:DefragmentationInfo2] :: DefragmentationInfo2 -> Ptr Bool32

-- | Either null or pointer to array of pools to be defragmented.
--   
--   All the allocations in the specified pools can be moved during
--   defragmentation and there is no way to check if they were really moved
--   as in <tt>pAllocationsChanged</tt>, so you must query all the
--   allocations in all these pools for new <tt>VkDeviceMemory</tt> and
--   offset using <a>getAllocationInfo</a> if you might need to recreate
--   buffers and images bound to them.
--   
--   The array should have <tt>poolCount</tt> elements. The array should
--   not contain nulls. Elements in the array should be unique - same pool
--   cannot occur twice.
--   
--   Using this array is equivalent to specifying all allocations from the
--   pools in <tt>pAllocations</tt>. It might be more efficient.
[$sel:pools:DefragmentationInfo2] :: DefragmentationInfo2 -> Vector Pool

-- | Maximum total numbers of bytes that can be copied while moving
--   allocations to different places using transfers on CPU side, like
--   <tt>memcpy()</tt>, <tt>memmove()</tt>.
--   
--   <tt>VK_WHOLE_SIZE</tt> means no limit.
[$sel:maxCpuBytesToMove:DefragmentationInfo2] :: DefragmentationInfo2 -> DeviceSize

-- | Maximum number of allocations that can be moved to a different place
--   using transfers on CPU side, like <tt>memcpy()</tt>,
--   <tt>memmove()</tt>.
--   
--   <tt>UINT32_MAX</tt> means no limit.
[$sel:maxCpuAllocationsToMove:DefragmentationInfo2] :: DefragmentationInfo2 -> Word32

-- | Maximum total numbers of bytes that can be copied while moving
--   allocations to different places using transfers on GPU side, posted to
--   <tt>commandBuffer</tt>.
--   
--   <tt>VK_WHOLE_SIZE</tt> means no limit.
[$sel:maxGpuBytesToMove:DefragmentationInfo2] :: DefragmentationInfo2 -> DeviceSize

-- | Maximum number of allocations that can be moved to a different place
--   using transfers on GPU side, posted to <tt>commandBuffer</tt>.
--   
--   <tt>UINT32_MAX</tt> means no limit.
[$sel:maxGpuAllocationsToMove:DefragmentationInfo2] :: DefragmentationInfo2 -> Word32

-- | Optional. Command buffer where GPU copy commands will be posted.
--   
--   If not null, it must be a valid command buffer handle that supports
--   Transfer queue type. It must be in the recording state and outside of
--   a render pass instance. You need to submit it and make sure it
--   finished execution before calling <a>defragmentationEnd</a>.
--   
--   Passing null means that only CPU defragmentation will be performed.
[$sel:commandBuffer:DefragmentationInfo2] :: DefragmentationInfo2 -> Ptr CommandBuffer_T

-- | VmaDefragmentationPassMoveInfo
data DefragmentationPassMoveInfo
DefragmentationPassMoveInfo :: Allocation -> DeviceMemory -> DeviceSize -> DefragmentationPassMoveInfo
[$sel:allocation:DefragmentationPassMoveInfo] :: DefragmentationPassMoveInfo -> Allocation
[$sel:memory:DefragmentationPassMoveInfo] :: DefragmentationPassMoveInfo -> DeviceMemory
[$sel:offset:DefragmentationPassMoveInfo] :: DefragmentationPassMoveInfo -> DeviceSize

-- | VmaDefragmentationPassInfo
--   
--   Parameters for incremental defragmentation steps.
--   
--   To be used with function <a>beginDefragmentationPass</a>.
data DefragmentationPassInfo
DefragmentationPassInfo :: Word32 -> Ptr DefragmentationPassMoveInfo -> DefragmentationPassInfo
[$sel:moveCount:DefragmentationPassInfo] :: DefragmentationPassInfo -> Word32
[$sel:moves:DefragmentationPassInfo] :: DefragmentationPassInfo -> Ptr DefragmentationPassMoveInfo

-- | VmaDefragmentationInfo
--   
--   Deprecated. Optional configuration parameters to be passed to function
--   <a>defragment</a>.
--   
--   <i>Deprecated</i>
--   
--   This is a part of the old interface. It is recommended to use
--   structure <a>DefragmentationInfo2</a> and function
--   <a>defragmentationBegin</a> instead.
data DefragmentationInfo
DefragmentationInfo :: DeviceSize -> Word32 -> DefragmentationInfo

-- | Maximum total numbers of bytes that can be copied while moving
--   allocations to different places.
--   
--   Default is <tt>VK_WHOLE_SIZE</tt>, which means no limit.
[$sel:maxBytesToMove:DefragmentationInfo] :: DefragmentationInfo -> DeviceSize

-- | Maximum number of allocations that can be moved to different place.
--   
--   Default is <tt>UINT32_MAX</tt>, which means no limit.
[$sel:maxAllocationsToMove:DefragmentationInfo] :: DefragmentationInfo -> Word32

-- | VmaDefragmentationStats
--   
--   Statistics returned by function <a>defragment</a>.
data DefragmentationStats
DefragmentationStats :: DeviceSize -> DeviceSize -> Word32 -> Word32 -> DefragmentationStats

-- | Total number of bytes that have been copied while moving allocations
--   to different places.
[$sel:bytesMoved:DefragmentationStats] :: DefragmentationStats -> DeviceSize

-- | Total number of bytes that have been released to the system by freeing
--   empty <tt>VkDeviceMemory</tt> objects.
[$sel:bytesFreed:DefragmentationStats] :: DefragmentationStats -> DeviceSize

-- | Number of allocations that have been moved to different places.
[$sel:allocationsMoved:DefragmentationStats] :: DefragmentationStats -> Word32

-- | Number of empty <tt>VkDeviceMemory</tt> objects that have been
--   released to the system.
[$sel:deviceMemoryBlocksFreed:DefragmentationStats] :: DefragmentationStats -> Word32
instance Data.Bits.Bits VulkanMemoryAllocator.DefragmentationFlagBits
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DefragmentationFlagBits
instance Foreign.Storable.Storable VulkanMemoryAllocator.DefragmentationFlagBits
instance GHC.Classes.Ord VulkanMemoryAllocator.DefragmentationFlagBits
instance GHC.Classes.Eq VulkanMemoryAllocator.DefragmentationFlagBits
instance Vulkan.Core10.APIConstants.IsHandle VulkanMemoryAllocator.DefragmentationContext
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DefragmentationContext
instance Foreign.Storable.Storable VulkanMemoryAllocator.DefragmentationContext
instance GHC.Classes.Ord VulkanMemoryAllocator.DefragmentationContext
instance GHC.Classes.Eq VulkanMemoryAllocator.DefragmentationContext
instance Vulkan.Core10.APIConstants.IsHandle VulkanMemoryAllocator.Allocation
instance Vulkan.Zero.Zero VulkanMemoryAllocator.Allocation
instance Foreign.Storable.Storable VulkanMemoryAllocator.Allocation
instance GHC.Classes.Ord VulkanMemoryAllocator.Allocation
instance GHC.Classes.Eq VulkanMemoryAllocator.Allocation
instance Data.Bits.Bits VulkanMemoryAllocator.PoolCreateFlagBits
instance Vulkan.Zero.Zero VulkanMemoryAllocator.PoolCreateFlagBits
instance Foreign.Storable.Storable VulkanMemoryAllocator.PoolCreateFlagBits
instance GHC.Classes.Ord VulkanMemoryAllocator.PoolCreateFlagBits
instance GHC.Classes.Eq VulkanMemoryAllocator.PoolCreateFlagBits
instance Data.Bits.Bits VulkanMemoryAllocator.AllocationCreateFlagBits
instance Vulkan.Zero.Zero VulkanMemoryAllocator.AllocationCreateFlagBits
instance Foreign.Storable.Storable VulkanMemoryAllocator.AllocationCreateFlagBits
instance GHC.Classes.Ord VulkanMemoryAllocator.AllocationCreateFlagBits
instance GHC.Classes.Eq VulkanMemoryAllocator.AllocationCreateFlagBits
instance Vulkan.Zero.Zero VulkanMemoryAllocator.MemoryUsage
instance Foreign.Storable.Storable VulkanMemoryAllocator.MemoryUsage
instance GHC.Classes.Ord VulkanMemoryAllocator.MemoryUsage
instance GHC.Classes.Eq VulkanMemoryAllocator.MemoryUsage
instance Vulkan.Core10.APIConstants.IsHandle VulkanMemoryAllocator.Pool
instance Vulkan.Zero.Zero VulkanMemoryAllocator.Pool
instance Foreign.Storable.Storable VulkanMemoryAllocator.Pool
instance GHC.Classes.Ord VulkanMemoryAllocator.Pool
instance GHC.Classes.Eq VulkanMemoryAllocator.Pool
instance Data.Bits.Bits VulkanMemoryAllocator.RecordFlagBits
instance Vulkan.Zero.Zero VulkanMemoryAllocator.RecordFlagBits
instance Foreign.Storable.Storable VulkanMemoryAllocator.RecordFlagBits
instance GHC.Classes.Ord VulkanMemoryAllocator.RecordFlagBits
instance GHC.Classes.Eq VulkanMemoryAllocator.RecordFlagBits
instance Data.Bits.Bits VulkanMemoryAllocator.AllocatorCreateFlagBits
instance Vulkan.Zero.Zero VulkanMemoryAllocator.AllocatorCreateFlagBits
instance Foreign.Storable.Storable VulkanMemoryAllocator.AllocatorCreateFlagBits
instance GHC.Classes.Ord VulkanMemoryAllocator.AllocatorCreateFlagBits
instance GHC.Classes.Eq VulkanMemoryAllocator.AllocatorCreateFlagBits
instance Vulkan.Core10.APIConstants.IsHandle VulkanMemoryAllocator.Allocator
instance Vulkan.Zero.Zero VulkanMemoryAllocator.Allocator
instance Foreign.Storable.Storable VulkanMemoryAllocator.Allocator
instance GHC.Classes.Ord VulkanMemoryAllocator.Allocator
instance GHC.Classes.Eq VulkanMemoryAllocator.Allocator
instance GHC.Show.Show VulkanMemoryAllocator.DeviceMemoryCallbacks
instance GHC.Show.Show VulkanMemoryAllocator.VulkanFunctions
instance GHC.Show.Show VulkanMemoryAllocator.RecordSettings
instance GHC.Show.Show VulkanMemoryAllocator.AllocatorCreateInfo
instance GHC.Show.Show VulkanMemoryAllocator.AllocatorInfo
instance GHC.Show.Show VulkanMemoryAllocator.StatInfo
instance GHC.Show.Show VulkanMemoryAllocator.Stats
instance GHC.Show.Show VulkanMemoryAllocator.Budget
instance GHC.Show.Show VulkanMemoryAllocator.AllocationCreateInfo
instance GHC.Show.Show VulkanMemoryAllocator.PoolCreateInfo
instance GHC.Show.Show VulkanMemoryAllocator.PoolStats
instance GHC.Show.Show VulkanMemoryAllocator.AllocationInfo
instance GHC.Show.Show VulkanMemoryAllocator.DefragmentationInfo2
instance GHC.Show.Show VulkanMemoryAllocator.DefragmentationPassMoveInfo
instance GHC.Show.Show VulkanMemoryAllocator.DefragmentationPassInfo
instance GHC.Show.Show VulkanMemoryAllocator.DefragmentationInfo
instance GHC.Show.Show VulkanMemoryAllocator.DefragmentationStats
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.DefragmentationStats
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.DefragmentationStats
instance Foreign.Storable.Storable VulkanMemoryAllocator.DefragmentationStats
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DefragmentationStats
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.DefragmentationInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.DefragmentationInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.DefragmentationInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DefragmentationInfo
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.DefragmentationPassInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.DefragmentationPassInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.DefragmentationPassInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DefragmentationPassInfo
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.DefragmentationPassMoveInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.DefragmentationPassMoveInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.DefragmentationPassMoveInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DefragmentationPassMoveInfo
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.DefragmentationInfo2
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.DefragmentationInfo2
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DefragmentationInfo2
instance GHC.Show.Show VulkanMemoryAllocator.DefragmentationFlagBits
instance GHC.Read.Read VulkanMemoryAllocator.DefragmentationFlagBits
instance GHC.Show.Show VulkanMemoryAllocator.DefragmentationContext
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.AllocationInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.AllocationInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.AllocationInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.AllocationInfo
instance GHC.Show.Show VulkanMemoryAllocator.Allocation
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.PoolStats
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.PoolStats
instance Foreign.Storable.Storable VulkanMemoryAllocator.PoolStats
instance Vulkan.Zero.Zero VulkanMemoryAllocator.PoolStats
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.PoolCreateInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.PoolCreateInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.PoolCreateInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.PoolCreateInfo
instance GHC.Show.Show VulkanMemoryAllocator.PoolCreateFlagBits
instance GHC.Read.Read VulkanMemoryAllocator.PoolCreateFlagBits
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.AllocationCreateInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.AllocationCreateInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.AllocationCreateInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.AllocationCreateInfo
instance GHC.Show.Show VulkanMemoryAllocator.AllocationCreateFlagBits
instance GHC.Read.Read VulkanMemoryAllocator.AllocationCreateFlagBits
instance GHC.Show.Show VulkanMemoryAllocator.MemoryUsage
instance GHC.Read.Read VulkanMemoryAllocator.MemoryUsage
instance GHC.Show.Show VulkanMemoryAllocator.Pool
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.Budget
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.Budget
instance Foreign.Storable.Storable VulkanMemoryAllocator.Budget
instance Vulkan.Zero.Zero VulkanMemoryAllocator.Budget
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.Stats
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.Stats
instance Foreign.Storable.Storable VulkanMemoryAllocator.Stats
instance Vulkan.Zero.Zero VulkanMemoryAllocator.Stats
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.StatInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.StatInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.StatInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.StatInfo
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.AllocatorInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.AllocatorInfo
instance Foreign.Storable.Storable VulkanMemoryAllocator.AllocatorInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.AllocatorInfo
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.AllocatorCreateInfo
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.AllocatorCreateInfo
instance Vulkan.Zero.Zero VulkanMemoryAllocator.AllocatorCreateInfo
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.RecordSettings
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.RecordSettings
instance Vulkan.Zero.Zero VulkanMemoryAllocator.RecordSettings
instance GHC.Show.Show VulkanMemoryAllocator.RecordFlagBits
instance GHC.Read.Read VulkanMemoryAllocator.RecordFlagBits
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.VulkanFunctions
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.VulkanFunctions
instance Foreign.Storable.Storable VulkanMemoryAllocator.VulkanFunctions
instance Vulkan.Zero.Zero VulkanMemoryAllocator.VulkanFunctions
instance GHC.Show.Show VulkanMemoryAllocator.AllocatorCreateFlagBits
instance GHC.Read.Read VulkanMemoryAllocator.AllocatorCreateFlagBits
instance Vulkan.CStruct.ToCStruct VulkanMemoryAllocator.DeviceMemoryCallbacks
instance Vulkan.CStruct.FromCStruct VulkanMemoryAllocator.DeviceMemoryCallbacks
instance Foreign.Storable.Storable VulkanMemoryAllocator.DeviceMemoryCallbacks
instance Vulkan.Zero.Zero VulkanMemoryAllocator.DeviceMemoryCallbacks
instance GHC.Show.Show VulkanMemoryAllocator.Allocator
